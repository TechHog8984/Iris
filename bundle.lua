--[=[
    Built with TechHog's ScriptBuilder.
    Report bugs directly to TechHog#8984
    or through his discord server at discord.gg/9xHUHFyvR7

    Script: Iris
    Files: 4
    Characters: 104,222 (154,624 before minify)
    Lines: 24 (3,850 before minify)
    Build date: 05/28/23
    Minified?: true
    middleclass?: false
    AutoEntryTable?: false
    Signal?: false
]=]
local ModuleExports, ModuleCache, ModuleShared = {},{},{
    oldrequire = require
};
local function require(path)
    if not ModuleCache[path] then
        local module = assert(ModuleExports[path], "Failed to find module named " .. string.format("%q", path));
        ModuleCache[path] = {module()};
    end;
    return unpack(ModuleCache[path]);
end;
local function f_module_widgets()
local GuiService = game:GetService("GuiService") local UserInputService = game:GetService("UserInputService") local ICONS = { RIGHT_POINTING_TRIANGLE = "\u{25BA}", DOWN_POINTING_TRIANGLE = "\u{25BC}", MULTIPLICATION_SIGN = "\u{00D7}",  BOTTOM_RIGHT_CORNER = "\u{25E2}",  CHECK_MARK = "\u{2713}"} local function UIPadding(Parent, PxPadding) local UIPadding = Instance.new("UIPadding") UIPadding.PaddingLeft = UDim.new(0, PxPadding.X) UIPadding.PaddingRight = UDim.new(0, PxPadding.X) UIPadding.PaddingTop = UDim.new(0, PxPadding.Y) UIPadding.PaddingBottom = UDim.new(0, PxPadding.Y) UIPadding.Parent = Parent return UIPadding end local function Folder(Parent) local ThisFolder = Instance.new("Folder") ThisFolder.Parent = Parent return ThisFolder end local function UISizeConstraint(Parent, MinSize, MaxSize) local UISizeConstraint = Instance.new("UISizeConstraint") UISizeConstraint.MinSize = MinSize UISizeConstraint.MaxSize = MaxSize UISizeConstraint.Parent = Parent return UISizeConstraint end local function UIListLayout(Parent, FillDirection, Padding) local UIListLayout = Instance.new("UIListLayout") UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder UIListLayout.Padding = Padding UIListLayout.FillDirection = FillDirection UIListLayout.Parent = Parent return UIListLayout end local function UIStroke(Parent, Thickness, Color, Transparency) local UIStroke = Instance.new("UIStroke") UIStroke.Thickness = Thickness UIStroke.Color = Color UIStroke.Transparency = Transparency UIStroke.Parent = Parent return UIStroke end local function UICorner(Parent, PxRounding) local UICorner = Instance.new("UICorner") UICorner.CornerRadius = UDim.new(0, PxRounding) UICorner.Parent = Parent return UICorner end local function UITableLayout(Parent) local UITableLayout = Instance.new("UITableLayout") UITableLayout.MajorAxis = Enum.TableMajorAxis.ColumnMajor UITableLayout.Parent = Parent return UITableLayout end return function(Iris) local function applyTextStyle(thisInstance) thisInstance.Font = Iris._config.TextFont thisInstance.TextSize = Iris._config.TextSize thisInstance.TextColor3 = Iris._config.TextColor thisInstance.TextTransparency = Iris._config.TextTransparency thisInstance.TextXAlignment = Enum.TextXAlignment.Left thisInstance.AutoLocalize = false thisInstance.RichText = false end local function applyInteractionHighlights(Button, Highlightee, Colors, Mode: "Text" | "Background" | nil) local exitedButton = false Button.MouseEnter:Connect(function() if Mode == "Text" then Highlightee.TextColor3 = Colors.ButtonHoveredColor Highlightee.TextTransparency = Colors.ButtonHoveredTransparency else Highlightee.BackgroundColor3 = Colors.ButtonHoveredColor Highlightee.BackgroundTransparency = Colors.ButtonHoveredTransparency end exitedButton = false end) Button.MouseLeave:Connect(function() if Mode == "Text" then Highlightee.TextColor3 = Colors.ButtonColor Highlightee.TextTransparency = Colors.ButtonTransparency else Highlightee.BackgroundColor3 = Colors.ButtonColor Highlightee.BackgroundTransparency = Colors.ButtonTransparency end exitedButton = true end) Button.InputBegan:Connect(function(input) if not (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Gamepad1) then return end if Mode == "Text" then Highlightee.TextColor3 = Colors.ButtonActiveColor Highlightee.TextTransparency = Colors.ButtonActiveTransparency else Highlightee.BackgroundColor3 = Colors.ButtonActiveColor Highlightee.BackgroundTransparency = Colors.ButtonActiveTransparency end end) Button.InputEnded:Connect(function(input) if not (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Gamepad1) or exitedButton then return end if input.UserInputType == Enum.UserInputType.MouseButton1 then if Mode == "Text" then Highlightee.TextColor3 = Colors.ButtonHoveredColor Highlightee.TextTransparency = Colors.ButtonHoveredTransparency else Highlightee.BackgroundColor3 = Colors.ButtonHoveredColor Highlightee.BackgroundTransparency = Colors.ButtonHoveredTransparency end end if input.UserInputType == Enum.UserInputType.Gamepad1 then if Mode == "Text" then Highlightee.TextColor3 = Colors.ButtonColor Highlightee.TextTransparency = Colors.ButtonTransparency else Highlightee.BackgroundColor3 = Colors.ButtonColor Highlightee.BackgroundTransparency = Colors.ButtonTransparency end end end)  Button.SelectionImageObject = Iris.SelectionImageObject end local function applyFrameStyle(thisInstance, forceNoPadding)   local FramePadding = Iris._config.FramePadding local FrameBorderTransparency = Iris._config.ButtonTransparency local FrameBorderSize = Iris._config.FrameBorderSize local FrameBorderColor = Iris._config.BorderColor local FrameRounding = Iris._config.FrameRounding  if FrameBorderSize > 0 and FrameRounding > 0 then thisInstance.BorderSizePixel = 0 local UIStroke = Instance.new("UIStroke") UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border UIStroke.LineJoinMode = Enum.LineJoinMode.Round UIStroke.Transparency = FrameBorderTransparency UIStroke.Thickness = FrameBorderSize UIStroke.Color = FrameBorderColor UICorner(thisInstance, FrameRounding) UIStroke.Parent = thisInstance if not forceNoPadding then UIPadding(thisInstance, Iris._config.FramePadding) end elseif FrameBorderSize < 1 and FrameRounding > 0 then thisInstance.BorderSizePixel = 0 UICorner(thisInstance, FrameRounding) if not forceNoPadding then UIPadding(thisInstance, Iris._config.FramePadding) end elseif FrameRounding < 1 then thisInstance.BorderSizePixel = FrameBorderSize thisInstance.BorderColor3 = FrameBorderColor thisInstance.BorderMode = Enum.BorderMode.Inset if not forceNoPadding then UIPadding(thisInstance, FramePadding - Vector2.new(FrameBorderSize, FrameBorderSize)) else UIPadding(thisInstance, -Vector2.new(FrameBorderSize, FrameBorderSize)) end end end local function commonButton() local Button = Instance.new("TextButton") Button.Name = "Iris_Button" Button.Size = UDim2.fromOffset(0, 0) Button.BackgroundColor3 = Iris._config.ButtonColor Button.BackgroundTransparency = Iris._config.ButtonTransparency Button.AutoButtonColor = false applyTextStyle(Button) Button.AutomaticSize = Enum.AutomaticSize.XY applyFrameStyle(Button) applyInteractionHighlights(Button, Button, { ButtonColor = Iris._config.ButtonColor, ButtonTransparency = Iris._config.ButtonTransparency, ButtonHoveredColor = Iris._config.ButtonHoveredColor, ButtonHoveredTransparency = Iris._config.ButtonHoveredTransparency, ButtonActiveColor = Iris._config.ButtonActiveColor, ButtonActiveTransparency = Iris._config.ButtonActiveTransparency, }) return Button end local function discardState(thisWidget) for i,state in thisWidget.state do state.ConnectedWidgets[thisWidget.ID] = nil end end do  local NumNonWindowChildren = 0 Iris.WidgetConstructor("Root", false, true, { Args = {}, Generate = function(thisWidget) local Root = Instance.new("Folder") Root.Name = "Iris_Root" local PseudoWindowScreenGui if Iris._config.UseScreenGUIs then PseudoWindowScreenGui = Instance.new("ScreenGui") PseudoWindowScreenGui.ResetOnSpawn = false PseudoWindowScreenGui.DisplayOrder = Iris._config.DisplayOrderOffset else PseudoWindowScreenGui = Instance.new("Folder") end PseudoWindowScreenGui.Name = "PseudoWindowScreenGui" PseudoWindowScreenGui.Parent = Root  local PseudoWindow = Instance.new("Frame") PseudoWindow.Name = "PseudoWindow" PseudoWindow.Size = UDim2.new(0, 0, 0, 0) PseudoWindow.Position = UDim2.fromOffset(0, 22) PseudoWindow.BorderSizePixel = Iris._config.WindowBorderSize PseudoWindow.BorderColor3 = Iris._config.BorderColor PseudoWindow.BackgroundTransparency = Iris._config.WindowBgTransparency PseudoWindow.BackgroundColor3 = Iris._config.WindowBgColor PseudoWindow.AutomaticSize = Enum.AutomaticSize.XY PseudoWindow.Selectable = false PseudoWindow.SelectionGroup = true PseudoWindow.SelectionBehaviorUp = Enum.SelectionBehavior.Stop PseudoWindow.SelectionBehaviorDown = Enum.SelectionBehavior.Stop PseudoWindow.SelectionBehaviorLeft = Enum.SelectionBehavior.Stop PseudoWindow.SelectionBehaviorRight = Enum.SelectionBehavior.Stop PseudoWindow.Visible = false UIPadding(PseudoWindow, Iris._config.WindowPadding) UIListLayout(PseudoWindow, Enum.FillDirection.Vertical, UDim.new(0, Iris._config.ItemSpacing.Y)) PseudoWindow.Parent = PseudoWindowScreenGui  return Root end, Update = function(thisWidget) if NumNonWindowChildren > 0 then thisWidget.Instance.PseudoWindowScreenGui.PseudoWindow.Visible = true end end, Discard = function(thisWidget) NumNonWindowChildren = 0 thisWidget.Instance:Destroy() end, ChildAdded = function(thisWidget, childWidget) if childWidget.type == "Window" then return thisWidget.Instance else NumNonWindowChildren += 1 thisWidget.Instance.PseudoWindowScreenGui.PseudoWindow.Visible = true return thisWidget.Instance.PseudoWindowScreenGui.PseudoWindow end end, ChildDiscarded = function(thisWidget, childWidget) if childWidget.type ~= "Window" then NumNonWindowChildren -= 1 if NumNonWindowChildren == 0 then thisWidget.Instance.PseudoWindowScreenGui.PseudoWindow.Visible = false end end end }) end Iris.WidgetConstructor("Text", false, false, { Args = { ["Text"] = 1 }, Generate = function(thisWidget) local Text = Instance.new("TextLabel") Text.Name = "Iris_Text" Text.Size = UDim2.fromOffset(0, 0) Text.BackgroundTransparency = 1 Text.BorderSizePixel = 0 Text.ZIndex = thisWidget.ZIndex Text.LayoutOrder = thisWidget.ZIndex Text.AutomaticSize = Enum.AutomaticSize.XY applyTextStyle(Text) UIPadding(Text, Vector2.new(0, 2))  return Text end, Update = function(thisWidget) local Text = thisWidget.Instance if thisWidget.arguments.Text == nil then error("Iris.Text Text Argument is required", 5) end Text.Text = thisWidget.arguments.Text end, Discard = function(thisWidget) thisWidget.Instance:Destroy() end}) Iris.Text = function(args) return Iris._Insert("Text", args) end Iris.WidgetConstructor("TextWrapped", false, false, { Args = { ["Text"] = 1 }, Generate = function(thisWidget) local TextWrapped = Instance.new("TextLabel") TextWrapped.Name = "Iris_Text" TextWrapped.Size = UDim2.new(Iris._config.ItemWidth, UDim.new(0, 0)) TextWrapped.BackgroundTransparency = 1 TextWrapped.BorderSizePixel = 0 TextWrapped.ZIndex = thisWidget.ZIndex TextWrapped.LayoutOrder = thisWidget.ZIndex TextWrapped.AutomaticSize = Enum.AutomaticSize.Y TextWrapped.TextWrapped = true applyTextStyle(TextWrapped) UIPadding(TextWrapped, Vector2.new(0, 2))  return TextWrapped end, Update = function(thisWidget) local TextWrapped = thisWidget.Instance if thisWidget.arguments.Text == nil then error("Iris.TextWrapped Text Argument is required", 5) end TextWrapped.Text = thisWidget.arguments.Text end, Discard = function(thisWidget) thisWidget.Instance:Destroy() end}) Iris.TextWrapped = function(args) return Iris._Insert("TextWrapped", args) end Iris.WidgetConstructor("Button", false, false, { Args = { ["Text"] = 1 }, Generate = function(thisWidget) local Button = commonButton() Button.ZIndex = thisWidget.ZIndex Button.LayoutOrder = thisWidget.ZIndex Button.MouseButton1Click:Connect(function() thisWidget.events.clicked = true end) return Button end, Update = function(thisWidget) local Button = thisWidget.Instance Button.Text = thisWidget.arguments.Text or "Button" end, Discard = function(thisWidget) thisWidget.Instance:Destroy() end}) Iris.Button = function(args) return Iris._Insert("Button", args) end Iris.WidgetConstructor("SmallButton", false, false, { Args = { ["Text"] = 1 }, Generate = function(thisWidget) local SmallButton = commonButton() SmallButton.Name = "Iris_SmallButton" SmallButton.ZIndex = thisWidget.ZIndex SmallButton.LayoutOrder = thisWidget.ZIndex SmallButton.MouseButton1Click:Connect(function() thisWidget.events.clicked = true end) local UIPadding = SmallButton.UIPadding UIPadding.PaddingLeft = UDim.new(0, 2) UIPadding.PaddingRight = UDim.new(0, 2) UIPadding.PaddingTop = UDim.new(0, 0) UIPadding.PaddingBottom = UDim.new(0, 0) return SmallButton end, Update = function(thisWidget) local SmallButton = thisWidget.Instance SmallButton.Text = thisWidget.arguments.Text or "SmallButton" end, Discard = function(thisWidget) thisWidget.Instance:Destroy() end}) Iris.SmallButton = function(args) return Iris._Insert("SmallButton", args) end Iris.WidgetConstructor("Separator", false, false, { Args = {}, Generate = function(thisWidget) local Separator = Instance.new("Frame") Separator.Name = "Iris_Separator" Separator.BorderSizePixel = 0 if thisWidget.parentWidget.type == "SameLine" then Separator.Size = UDim2.new(0, 1, 1, 0) else Separator.Size = UDim2.new(1, 0, 0, 1) end Separator.ZIndex = thisWidget.ZIndex Separator.LayoutOrder = thisWidget.ZIndex Separator.BackgroundColor3 = Iris._config.SeparatorColor Separator.BackgroundTransparency = Iris._config.SeparatorTransparency UIListLayout(Separator, Enum.FillDirection.Vertical, UDim.new(0,0))  return Separator end, Update = function(thisWidget) end, Discard = function(thisWidget) thisWidget.Instance:Destroy() end}) Iris.Separator = function(args) return Iris._Insert("Separator", args) end Iris.WidgetConstructor("Indent", false, true, { Args = { ["Width"] = 1, }, Generate = function(thisWidget) local Indent = Instance.new("Frame") Indent.Name = "Iris_Indent" Indent.BackgroundTransparency = 1 Indent.BorderSizePixel = 0 Indent.ZIndex = thisWidget.ZIndex Indent.LayoutOrder = thisWidget.ZIndex Indent.Size = UDim2.fromScale(1, 0) Indent.AutomaticSize = Enum.AutomaticSize.Y UIListLayout(Indent, Enum.FillDirection.Vertical, UDim.new(0, Iris._config.ItemSpacing.Y)) UIPadding(Indent, Vector2.new(0, 0)) return Indent end, Update = function(thisWidget) local indentWidth if thisWidget.arguments.Width then indentWidth = thisWidget.arguments.Width else indentWidth = Iris._config.IndentSpacing end thisWidget.Instance.UIPadding.PaddingLeft = UDim.new(0, indentWidth) end, Discard = function(thisWidget) thisWidget.Instance:Destroy() end, ChildAdded = function(thisWidget) return thisWidget.Instance end}) Iris.Indent = function(args) return Iris._Insert("Indent", args) end Iris.WidgetConstructor("SameLine", false, true, { Args = { ["Width"] = 1, ["VerticalAlignment"] = 2 }, Generate = function(thisWidget) local SameLine = Instance.new("Frame") SameLine.Name = "Iris_SameLine" SameLine.BackgroundTransparency = 1 SameLine.BorderSizePixel = 0 SameLine.ZIndex = thisWidget.ZIndex SameLine.LayoutOrder = thisWidget.ZIndex SameLine.Size = UDim2.fromScale(1, 0) SameLine.AutomaticSize = Enum.AutomaticSize.Y UIListLayout(SameLine, Enum.FillDirection.Horizontal, UDim.new(0, 0)) return SameLine end, Update = function(thisWidget) local itemWidth local UIListLayout = thisWidget.Instance.UIListLayout if thisWidget.arguments.Width then itemWidth = thisWidget.arguments.Width else itemWidth = Iris._config.ItemSpacing.X end UIListLayout.Padding = UDim.new(0, itemWidth) if thisWidget.arguments.VerticalAlignment then UIListLayout.VerticalAlignment = thisWidget.arguments.VerticalAlignment else UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center end end, Discard = function(thisWidget) thisWidget.Instance:Destroy() end, ChildAdded = function(thisWidget) return thisWidget.Instance end}) Iris.SameLine = function(args) return Iris._Insert("SameLine", args) end Iris.WidgetConstructor("Group", false, true, { Args = {}, Generate = function(thisWidget) local Group = Instance.new("Frame") Group.Name = "Iris_Group" Group.Size = UDim2.fromOffset(0, 0) Group.BackgroundTransparency = 1 Group.BorderSizePixel = 0 Group.ZIndex = thisWidget.ZIndex Group.LayoutOrder = thisWidget.ZIndex Group.AutomaticSize = Enum.AutomaticSize.XY local UIListLayout = UIListLayout(Group, Enum.FillDirection.Vertical, UDim.new(0, Iris._config.ItemSpacing.X)) return Group end, Update = function(thisWidget) end, Discard = function(thisWidget) thisWidget.Instance:Destroy() end, ChildAdded = function(thisWidget) return thisWidget.Instance end}) Iris.Group = function(args) return Iris._Insert("Group", args) end Iris.WidgetConstructor("Checkbox", true, false, { Args = { ["Text"] = 1 }, Generate = function(thisWidget) local Checkbox = Instance.new("TextButton") Checkbox.Name = "Iris_Checkbox" Checkbox.BackgroundTransparency = 1 Checkbox.BorderSizePixel = 0 Checkbox.Size = UDim2.fromOffset(0, 0) Checkbox.Text = "" Checkbox.AutomaticSize = Enum.AutomaticSize.XY Checkbox.ZIndex = thisWidget.ZIndex Checkbox.AutoButtonColor = false Checkbox.LayoutOrder = thisWidget.ZIndex local CheckboxBox = Instance.new("TextLabel") CheckboxBox.Name = "CheckboxBox" CheckboxBox.AutomaticSize = Enum.AutomaticSize.None local checkboxSize = Iris._config.TextSize + 2 * Iris._config.FramePadding.Y CheckboxBox.Size = UDim2.fromOffset(checkboxSize, checkboxSize) CheckboxBox.TextSize = checkboxSize CheckboxBox.LineHeight = 1.1 CheckboxBox.ZIndex = thisWidget.ZIndex + 1 CheckboxBox.LayoutOrder = thisWidget.ZIndex + 1 CheckboxBox.Parent = Checkbox CheckboxBox.TextColor3 = Iris._config.CheckMarkColor CheckboxBox.TextTransparency = Iris._config.CheckMarkTransparency CheckboxBox.BackgroundColor3 = Iris._config.FrameBgColor CheckboxBox.BackgroundTransparency = Iris._config.FrameBgTransparency applyFrameStyle(CheckboxBox, true) applyInteractionHighlights(Checkbox, CheckboxBox, { ButtonColor = Iris._config.FrameBgColor, ButtonTransparency = Iris._config.FrameBgTransparency, ButtonHoveredColor = Iris._config.FrameBgHoveredColor, ButtonHoveredTransparency = Iris._config.FrameBgHoveredTransparency, ButtonActiveColor = Iris._config.FrameBgActiveColor, ButtonActiveTransparency = Iris._config.FrameBgActiveTransparency, }) Checkbox.MouseButton1Click:Connect(function() local wasChecked = thisWidget.state.isChecked.value thisWidget.state.isChecked:set(not wasChecked) end) local TextLabel = Instance.new("TextLabel") TextLabel.Name = "TextLabel" applyTextStyle(TextLabel) TextLabel.Position = UDim2.new(0,checkboxSize + Iris._config.ItemInnerSpacing.X, 0.5, 0) TextLabel.ZIndex = thisWidget.ZIndex + 1 TextLabel.LayoutOrder = thisWidget.ZIndex + 1 TextLabel.AutomaticSize = Enum.AutomaticSize.XY TextLabel.AnchorPoint = Vector2.new(0, 0.5) TextLabel.BackgroundTransparency = 1 TextLabel.BorderSizePixel = 0 TextLabel.Parent = Checkbox return Checkbox end, Update = function(thisWidget) thisWidget.Instance.TextLabel.Text = thisWidget.arguments.Text or "Checkbox" end, Discard = function(thisWidget) thisWidget.Instance:Destroy() discardState(thisWidget) end, GenerateState = function(thisWidget) if thisWidget.state.isChecked == nil then thisWidget.state.isChecked = Iris._widgetState(thisWidget, "checked", false) end end, UpdateState = function(thisWidget) local Checkbox = thisWidget.Instance.CheckboxBox if thisWidget.state.isChecked.value then Checkbox.Text = ICONS.CHECK_MARK thisWidget.events.checked = true else Checkbox.Text = "" thisWidget.events.unchecked = true end end}) Iris.Checkbox = function(args, state) return Iris._Insert("Checkbox", args, state) end Iris.WidgetConstructor("Tree", true, true, { Args = { ["Text"] = 1, ["SpanAvailWidth"] = 2, ["NoIndent"] = 3 }, Generate = function(thisWidget) local Tree = Instance.new("Frame") Tree.Name = "Iris_Tree" Tree.BackgroundTransparency = 1 Tree.BorderSizePixel = 0 Tree.ZIndex = thisWidget.ZIndex Tree.LayoutOrder = thisWidget.ZIndex Tree.Size = UDim2.new(Iris._config.ItemWidth, UDim.new(0, 0)) Tree.AutomaticSize = Enum.AutomaticSize.Y thisWidget.hasChildren = false UIListLayout(Tree, Enum.FillDirection.Vertical, UDim.new(0, 0)) local ChildContainer = Instance.new("Frame") ChildContainer.Name = "ChildContainer" ChildContainer.BackgroundTransparency = 1 ChildContainer.BorderSizePixel = 0 ChildContainer.ZIndex = thisWidget.ZIndex + 1 ChildContainer.LayoutOrder = thisWidget.ZIndex + 1 ChildContainer.Size = UDim2.fromScale(1, 0) ChildContainer.AutomaticSize = Enum.AutomaticSize.Y ChildContainer.Visible = false ChildContainer.Parent = Tree UIListLayout(ChildContainer, Enum.FillDirection.Vertical, UDim.new(0, Iris._config.ItemSpacing.Y))  local ChildContainerPadding = UIPadding(ChildContainer, Vector2.new(0, 0)) ChildContainerPadding.PaddingTop = UDim.new(0, Iris._config.ItemSpacing.Y) local Header = Instance.new("Frame") Header.Name = "Header" Header.BackgroundTransparency = 1 Header.BorderSizePixel = 0 Header.ZIndex = thisWidget.ZIndex Header.LayoutOrder = thisWidget.ZIndex Header.Size = UDim2.fromScale(1, 0) Header.AutomaticSize = Enum.AutomaticSize.Y Header.Parent = Tree local Button = Instance.new("TextButton") Button.Name = "Button" Button.BackgroundTransparency = 1 Button.BorderSizePixel = 0 Button.ZIndex = thisWidget.ZIndex Button.LayoutOrder = thisWidget.ZIndex Button.AutoButtonColor = false Button.Text = "" Button.Parent = Header applyInteractionHighlights(Button, Header, { ButtonColor = Color3.fromRGB(0, 0, 0), ButtonTransparency = 1, ButtonHoveredColor = Iris._config.HeaderHoveredColor, ButtonHoveredTransparency = Iris._config.HeaderHoveredTransparency, ButtonActiveColor = Iris._config.HeaderActiveColor, ButtonActiveTransparency = Iris._config.HeaderActiveTransparency, }) local ButtonUIListLayout = UIListLayout(Button, Enum.FillDirection.Horizontal, UDim.new(0, 0)) ButtonUIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center local Arrow = Instance.new("TextLabel") Arrow.Name = "Arrow" Arrow.Size = UDim2.fromOffset(Iris._config.TextSize, 0) Arrow.BackgroundTransparency = 1 Arrow.BorderSizePixel = 0 Arrow.ZIndex = thisWidget.ZIndex Arrow.LayoutOrder = thisWidget.ZIndex Arrow.AutomaticSize = Enum.AutomaticSize.Y applyTextStyle(Arrow) Arrow.TextXAlignment = Enum.TextXAlignment.Center Arrow.TextSize = Iris._config.TextSize - 4 Arrow.Text = ICONS.RIGHT_POINTING_TRIANGLE Arrow.Parent = Button local TextLabel = Instance.new("TextLabel") TextLabel.Name = "TextLabel" TextLabel.Size = UDim2.fromOffset(0, 0) TextLabel.BackgroundTransparency = 1 TextLabel.BorderSizePixel = 0 TextLabel.ZIndex = thisWidget.ZIndex TextLabel.LayoutOrder = thisWidget.ZIndex TextLabel.AutomaticSize = Enum.AutomaticSize.XY TextLabel.Parent = Button local TextPadding = UIPadding(TextLabel,Vector2.new(0, 0)) TextPadding.PaddingRight = UDim.new(0, 21) applyTextStyle(TextLabel) Button.MouseButton1Click:Connect(function() thisWidget.state.isUncollapsed:set(not thisWidget.state.isUncollapsed.value) end) return Tree end, Update = function(thisWidget) local Button = thisWidget.Instance.Header.Button local ChildContainer = thisWidget.Instance.ChildContainer Button.TextLabel.Text = thisWidget.arguments.Text or "Tree" if thisWidget.arguments.SpanAvailWidth then Button.AutomaticSize = Enum.AutomaticSize.Y Button.Size = UDim2.fromScale(1, 0) else Button.AutomaticSize = Enum.AutomaticSize.XY Button.Size = UDim2.fromScale(0, 0) end if thisWidget.arguments.NoIndent then ChildContainer.UIPadding.PaddingLeft = UDim.new(0, 0) else ChildContainer.UIPadding.PaddingLeft = UDim.new(0, Iris._config.IndentSpacing) end end, Discard = function(thisWidget) thisWidget.Instance:Destroy() discardState(thisWidget) end, ChildAdded = function(thisWidget) local ChildContainer = thisWidget.Instance.ChildContainer local isUncollapsed = thisWidget.state.isUncollapsed.value thisWidget.hasChildren = true ChildContainer.Visible = isUncollapsed and thisWidget.hasChildren return thisWidget.Instance.ChildContainer end, UpdateState = function(thisWidget) local isUncollapsed = thisWidget.state.isUncollapsed.value local Arrow = thisWidget.Instance.Header.Button.Arrow local ChildContainer = thisWidget.Instance.ChildContainer Arrow.Text = (isUncollapsed and ICONS.DOWN_POINTING_TRIANGLE or ICONS.RIGHT_POINTING_TRIANGLE) if isUncollapsed then thisWidget.events.uncollapsed = true else thisWidget.events.collapsed = true end ChildContainer.Visible = isUncollapsed and thisWidget.hasChildren end, GenerateState = function(thisWidget) if thisWidget.state.isUncollapsed == nil then thisWidget.state.isUncollapsed = Iris._widgetState(thisWidget, "isUncollapsed", false) end end}) Iris.Tree = function(args, state) return Iris._Insert("Tree", args, state) end Iris.WidgetConstructor("InputNum", true, false, { Args = { ["Text"] = 1, ["Increment"] = 2, ["Min"] = 3, ["Max"] = 4, ["Format"] = 5, ["NoButtons"] = 6, ["NoField"] = 7 }, Generate = function(thisWidget) local InputNum = Instance.new("Frame") InputNum.Name = "Iris_InputNum" InputNum.Size = UDim2.new(Iris._config.ContentWidth, UDim.new(0, 0)) InputNum.BackgroundTransparency = 1 InputNum.BorderSizePixel = 0 InputNum.ZIndex = thisWidget.ZIndex InputNum.LayoutOrder = thisWidget.ZIndex InputNum.AutomaticSize = Enum.AutomaticSize.Y UIListLayout(InputNum, Enum.FillDirection.Horizontal, UDim.new(0, Iris._config.ItemInnerSpacing.X)) local inputButtonsWidth = Iris._config.TextSize local textLabelHeight = inputButtonsWidth + Iris._config.FramePadding.Y * 2 local InputField = Instance.new("TextBox") InputField.Name = "InputField" applyFrameStyle(InputField) applyTextStyle(InputField) InputField.UIPadding.PaddingLeft = UDim.new(0, Iris._config.ItemInnerSpacing.X) InputField.ZIndex = thisWidget.ZIndex + 1 InputField.LayoutOrder = thisWidget.ZIndex + 1 InputField.AutomaticSize = Enum.AutomaticSize.Y InputField.BackgroundColor3 = Iris._config.FrameBgColor InputField.BackgroundTransparency = Iris._config.FrameBgTransparency InputField.TextTruncate = Enum.TextTruncate.AtEnd InputField.Parent = InputNum InputField.FocusLost:Connect(function() local newValue = tonumber(InputField.Text) if newValue ~= nil then newValue = math.clamp(newValue, thisWidget.arguments.Min or -math.huge, thisWidget.arguments.Max or math.huge) thisWidget.state.number:set(newValue) thisWidget.events.numberChanged = true else InputField.Text = thisWidget.state.number.value end end) local SubButton = commonButton() SubButton.Name = "SubButton" SubButton.ZIndex = thisWidget.ZIndex + 2 SubButton.LayoutOrder = thisWidget.ZIndex + 2 SubButton.TextXAlignment = Enum.TextXAlignment.Center SubButton.Text = "-" SubButton.Size = UDim2.fromOffset(inputButtonsWidth - 2, inputButtonsWidth) SubButton.Parent = InputNum SubButton.MouseButton1Click:Connect(function() local newValue = thisWidget.state.number.value - (thisWidget.arguments.Increment or 1) newValue = math.clamp(newValue, thisWidget.arguments.Min or -math.huge, thisWidget.arguments.Max or math.huge) thisWidget.state.number:set(newValue) thisWidget.events.numberChanged = true end) local AddButton = commonButton() AddButton.Name = "AddButton" AddButton.ZIndex = thisWidget.ZIndex + 3 AddButton.LayoutOrder = thisWidget.ZIndex + 3 AddButton.TextXAlignment = Enum.TextXAlignment.Center AddButton.Text = "+" AddButton.Size = UDim2.fromOffset(inputButtonsWidth - 2, inputButtonsWidth) AddButton.Parent = InputNum AddButton.MouseButton1Click:Connect(function() local newValue = thisWidget.state.number.value + (thisWidget.arguments.Increment or 1) newValue = math.clamp(newValue, thisWidget.arguments.Min or -math.huge, thisWidget.arguments.Max or math.huge) thisWidget.state.number:set(newValue) thisWidget.events.numberChanged = true end) local TextLabel = Instance.new("TextLabel") TextLabel.Name = "TextLabel" TextLabel.Size = UDim2.fromOffset(0, textLabelHeight) TextLabel.BackgroundTransparency = 1 TextLabel.BorderSizePixel = 0 TextLabel.ZIndex = thisWidget.ZIndex + 4 TextLabel.LayoutOrder = thisWidget.ZIndex + 4 TextLabel.AutomaticSize = Enum.AutomaticSize.X applyTextStyle(TextLabel) TextLabel.Parent = InputNum return InputNum end, Update = function(thisWidget) local TextLabel = thisWidget.Instance.TextLabel TextLabel.Text = thisWidget.arguments.Text or "Input Num" thisWidget.Instance.SubButton.Visible = not thisWidget.arguments.NoButtons thisWidget.Instance.AddButton.Visible = not thisWidget.arguments.NoButtons local InputField = thisWidget.Instance.InputField InputField.Visible = not thisWidget.arguments.NoField local inputButtonsTotalWidth = Iris._config.TextSize * 2 + Iris._config.ItemInnerSpacing.X * 2 + Iris._config.WindowPadding.X + 4 if thisWidget.arguments.NoButtons then InputField.Size = UDim2.new(1, 0, 0, 0) else InputField.Size = UDim2.new(1, -inputButtonsTotalWidth, 0, 0) end end, Discard = function(thisWidget) thisWidget.Instance:Destroy() discardState(thisWidget) end, GenerateState = function(thisWidget) if thisWidget.state.number == nil then thisWidget.state.number = Iris._widgetState(thisWidget, "number", 0) end end, UpdateState = function(thisWidget) local InputField = thisWidget.Instance.InputField InputField.Text = string.format(thisWidget.arguments.Format or "%f", thisWidget.state.number.value) end}) Iris.InputNum = function(args, state) return Iris._Insert("InputNum", args, state) end Iris.WidgetConstructor("InputText", true, false, { Args = { ["Text"] = 1, ["TextHint"] = 2 }, Generate = function(thisWidget) local textLabelHeight = Iris._config.TextSize local InputText = Instance.new("Frame") InputText.Name = "Iris_InputText" InputText.Size = UDim2.new(Iris._config.ContentWidth, UDim.new(0, 0)) InputText.BackgroundTransparency = 1 InputText.BorderSizePixel = 0 InputText.ZIndex = thisWidget.ZIndex InputText.LayoutOrder = thisWidget.ZIndex InputText.AutomaticSize = Enum.AutomaticSize.Y UIListLayout(InputText, Enum.FillDirection.Horizontal, UDim.new(0, Iris._config.ItemInnerSpacing.X)) local InputField = Instance.new("TextBox") InputField.Name = "InputField" applyFrameStyle(InputField) applyTextStyle(InputField) InputField.UIPadding.PaddingLeft = UDim.new(0, Iris._config.ItemInnerSpacing.X) InputField.UIPadding.PaddingRight = UDim.new(0, 0) InputField.ZIndex = thisWidget.ZIndex + 1 InputField.LayoutOrder = thisWidget.ZIndex + 1 InputField.AutomaticSize = Enum.AutomaticSize.Y InputField.Size = UDim2.new(Iris._config.ContentWidth, UDim.new(0, 0)) InputField.BackgroundColor3 = Iris._config.FrameBgColor InputField.BackgroundTransparency = Iris._config.FrameBgTransparency InputField.ClearTextOnFocus = false InputField.Text = "" InputField.PlaceholderColor3 = Iris._config.TextDisabledColor InputField.TextTruncate = Enum.TextTruncate.AtEnd InputField.FocusLost:Connect(function() thisWidget.state.text:set(InputField.Text) thisWidget.events.textChanged = true end) InputField.Parent = InputText local TextLabel = Instance.new("TextLabel") TextLabel.Name = "TextLabel" TextLabel.Position = UDim2.new(1, Iris._config.ItemInnerSpacing.X, 0, 0) TextLabel.Size = UDim2.fromOffset(0, textLabelHeight) TextLabel.BackgroundTransparency = 1 TextLabel.BorderSizePixel = 0 TextLabel.ZIndex = thisWidget.ZIndex + 2 TextLabel.LayoutOrder = thisWidget.ZIndex + 2 TextLabel.AutomaticSize = Enum.AutomaticSize.X applyTextStyle(TextLabel) TextLabel.Parent = InputText return InputText end, Update = function(thisWidget) local TextLabel = thisWidget.Instance.TextLabel TextLabel.Text = thisWidget.arguments.Text or "Input Text" thisWidget.Instance.InputField.PlaceholderText = thisWidget.arguments.TextHint or "" end, Discard = function(thisWidget) thisWidget.Instance:Destroy() discardState(thisWidget) end, GenerateState = function(thisWidget) if thisWidget.state.text == nil then thisWidget.state.text = Iris._widgetState(thisWidget, "text", "") end end, UpdateState = function(thisWidget) thisWidget.Instance.InputField.Text = thisWidget.state.text.value end}) Iris.InputText = function(args, state) return Iris._Insert("InputText", args, state) end do  local tableWidgets = {} table.insert(Iris._postCycleCallbacks, function() for i,v in tableWidgets do v.RowColumnIndex = 0 end end) Iris.NextColumn = function() Iris._GetParentWidget().RowColumnIndex += 1 end Iris.SetColumnIndex = function(ColumnIndex) local ParentWidget = Iris._GetParentWidget() assert(ColumnIndex >= ParentWidget.InitialNumColumns, "Iris.SetColumnIndex Argument must be in column range") ParentWidget.RowColumnIndex = math.floor(ParentWidget.RowColumnIndex / ParentWidget.InitialNumColumns) + (ColumnIndex - 1) end Iris.NextRow = function()  local ParentWidget = Iris._GetParentWidget() local InitialNumColumns = ParentWidget.InitialNumColumns local nextRow = math.floor((ParentWidget.RowColumnIndex + 1) / InitialNumColumns) * InitialNumColumns ParentWidget.RowColumnIndex = nextRow end Iris.WidgetConstructor("Table", false, true, { Args = { ["NumColumns"] = 1, ["RowBg"] = 2, ["BordersOuter"] = 3, ["BordersInner"] = 4 }, Generate = function(thisWidget) tableWidgets[thisWidget.ID] = thisWidget thisWidget.InitialNumColumns = -1 thisWidget.RowColumnIndex = 0  thisWidget.ColumnInstances = {} thisWidget.CellInstances = {} local Table = Instance.new("Frame") Table.Name = "Iris_Table" Table.Size = UDim2.new(Iris._config.ItemWidth, UDim.new(0, 0)) Table.BackgroundTransparency = 1 Table.BorderSizePixel = 0 Table.ZIndex = thisWidget.ZIndex + 1024  Table.LayoutOrder = thisWidget.ZIndex Table.AutomaticSize = Enum.AutomaticSize.Y UIListLayout(Table, Enum.FillDirection.Horizontal, UDim.new(0, 0)) UIStroke(Table, 1, Iris._config.TableBorderStrongColor, Iris._config.TableBorderStrongTransparency) return Table end, Update = function(thisWidget) local thisWidgetInstance = thisWidget.Instance local ColumnInstances = thisWidget.ColumnInstances if thisWidget.arguments.BordersOuter == false then thisWidgetInstance.UIStroke.Thickness = 0 else thisWidget.Instance.UIStroke.Thickness = 1 end if thisWidget.InitialNumColumns == -1 then if thisWidget.arguments.NumColumns == nil then error("Iris.Table NumColumns argument is required", 5) end thisWidget.InitialNumColumns = thisWidget.arguments.NumColumns for i = 1, thisWidget.InitialNumColumns do local column = Instance.new("Frame") column.Name = `Column_{i}` column.BackgroundTransparency = 1 column.BorderSizePixel = 0 local ColumnZIndex = thisWidget.ZIndex + 1 + i column.ZIndex = ColumnZIndex column.LayoutOrder = ColumnZIndex column.AutomaticSize = Enum.AutomaticSize.Y column.Size = UDim2.new(1 / thisWidget.InitialNumColumns, 0, 0, 0) UIListLayout(column, Enum.FillDirection.Vertical, UDim.new(0, 0)) ColumnInstances[i] = column column.Parent = thisWidgetInstance end elseif thisWidget.arguments.NumColumns ~= thisWidget.InitialNumColumns then   error("Iris.Table NumColumns Argument must be static") end if thisWidget.arguments.RowBg == false then for _,v in thisWidget.CellInstances do v.BackgroundTransparency = 1 end else for rowColumnIndex,v in thisWidget.CellInstances do local currentRow = math.ceil((rowColumnIndex) / thisWidget.InitialNumColumns)  v.BackgroundTransparency = if currentRow % 2 == 0 then Iris._config.TableRowBgAltTransparency else Iris._config.TableRowBgTransparency end end if thisWidget.arguments.BordersInner == false then for _,v in thisWidget.CellInstances do v.UIStroke.Thickness = 0 end else for _,v in thisWidget.CellInstances do v.UIStroke.Thickness = 0.5 end end end, Discard = function(thisWidget) tableWidgets[thisWidget.ID] = nil thisWidget.Instance:Destroy() end, ChildAdded = function(thisWidget) if thisWidget.RowColumnIndex == 0 then thisWidget.RowColumnIndex = 1 end local potentialCellParent = thisWidget.CellInstances[thisWidget.RowColumnIndex] if potentialCellParent then return potentialCellParent end local cell = Instance.new("Frame") cell.AutomaticSize = Enum.AutomaticSize.Y cell.Size = UDim2.new(1, 0, 0, 0) cell.BackgroundTransparency = 1 cell.BorderSizePixel = 0 UIPadding(cell, Iris._config.CellPadding) local selectedParent = thisWidget.ColumnInstances[((thisWidget.RowColumnIndex - 1) % thisWidget.InitialNumColumns) + 1] local newZIndex = selectedParent.ZIndex + thisWidget.RowColumnIndex cell.ZIndex = newZIndex cell.LayoutOrder = newZIndex cell.Name = `Cell_{thisWidget.RowColumnIndex}` UIListLayout(cell, Enum.FillDirection.Vertical, UDim.new(0, Iris._config.ItemSpacing.Y)) if thisWidget.arguments.BordersInner == false then UIStroke(cell, 0, Iris._config.TableBorderLightColor, Iris._config.TableBorderLightTransparency) else UIStroke(cell, 0.5, Iris._config.TableBorderLightColor, Iris._config.TableBorderLightTransparency)   end if thisWidget.arguments.RowBg ~= false then local currentRow = math.ceil((thisWidget.RowColumnIndex) / thisWidget.InitialNumColumns) local color = if currentRow % 2 == 0 then Iris._config.TableRowBgAltColor else Iris._config.TableRowBgColor local transparency = if currentRow % 2 == 0 then Iris._config.TableRowBgAltTransparency else Iris._config.TableRowBgTransparency cell.BackgroundColor3 = color cell.BackgroundTransparency = transparency end thisWidget.CellInstances[thisWidget.RowColumnIndex] = cell cell.Parent = selectedParent return cell end }) Iris.Table = function(args, state) return Iris._Insert("Table", args, state) end end do  local windowDisplayOrder = 0  local dragWindow  local isDragging = false local moveDeltaCursorPosition  local resizeWindow  local isResizing = false local isInsideResize = false  local isInsideWindow = false  local resizeFromTopBottom = Enum.TopBottom.Top local resizeFromLeftRight = Enum.LeftRight.Left local lastCursorPosition local focusedWindow  local anyFocusedWindow = false  local windowWidgets = {}  local function getAbsoluteSize(thisWidget)   local size if thisWidget.usesScreenGUI then size = thisWidget.Instance.AbsoluteSize else local rootParent = thisWidget.Instance.Parent if rootParent:IsA("GuiBase2d") then size = rootParent.AbsoluteSize else if rootParent.Parent:IsA("GuiBase2d") then size = rootParent.AbsoluteSize else size = workspace.CurrentCamera.ViewportSize end end end return size end local function quickSwapWindows()  if Iris._config.UseScreenGUIs == false then return end local lowest = 0xFFFF local lowestWidget for i,v in windowWidgets do if v.state.isOpened.value and (not v.arguments.NoNav) then local value = v.Instance.DisplayOrder if value < lowest then lowest = value lowestWidget = v end end end if lowestWidget.state.isUncollapsed.value == false then lowestWidget.state.isUncollapsed:set(true) end Iris.SetFocusedWindow(lowestWidget) end local function fitSizeToWindowBounds(thisWidget, intentedSize) local windowSize = Vector2.new(thisWidget.state.position.value.X, thisWidget.state.position.value.Y) local minWindowSize = (Iris._config.TextSize + Iris._config.FramePadding.Y * 2) * 2 local usableSize = getAbsoluteSize(thisWidget) local maxWindowSize = ( usableSize - windowSize - Vector2.new(Iris._config.WindowBorderSize, Iris._config.WindowBorderSize) ) return Vector2.new( math.clamp(intentedSize.X, minWindowSize, math.max(maxWindowSize.X, minWindowSize)), math.clamp(intentedSize.Y, minWindowSize, math.max(maxWindowSize.Y, minWindowSize)) ) end local function fitPositionToWindowBounds(thisWidget, intendedPosition) local thisWidgetInstance = thisWidget.Instance local usableSize = getAbsoluteSize(thisWidget) return Vector2.new( math.clamp( intendedPosition.X, Iris._config.WindowBorderSize, math.max(Iris._config.WindowBorderSize, usableSize.X - thisWidgetInstance.WindowButton.AbsoluteSize.X - Iris._config.WindowBorderSize) ), math.clamp( intendedPosition.Y, Iris._config.WindowBorderSize,  math.max(Iris._config.WindowBorderSize, usableSize.Y - thisWidgetInstance.WindowButton.AbsoluteSize.Y - Iris._config.WindowBorderSize) ) ) end Iris.SetFocusedWindow = function(thisWidget: table | nil) if focusedWindow == thisWidget then return end if anyFocusedWindow then if windowWidgets[focusedWindow.ID] ~= nil then  local TitleBar = focusedWindow.Instance.WindowButton.TitleBar if focusedWindow.state.isUncollapsed.value then TitleBar.BackgroundColor3 = Iris._config.TitleBgColor TitleBar.BackgroundTransparency = Iris._config.TitleBgTransparency else TitleBar.BackgroundColor3 = Iris._config.TitleBgCollapsedColor TitleBar.BackgroundTransparency = Iris._config.TitleBgCollapsedTransparency end focusedWindow.Instance.WindowButton.UIStroke.Color = Iris._config.BorderColor end anyFocusedWindow = false focusedWindow = nil end if thisWidget ~= nil then  anyFocusedWindow = true focusedWindow = thisWidget local TitleBar = focusedWindow.Instance.WindowButton.TitleBar TitleBar.BackgroundColor3 = Iris._config.TitleBgActiveColor TitleBar.BackgroundTransparency = Iris._config.TitleBgActiveTransparency focusedWindow.Instance.WindowButton.UIStroke.Color = Iris._config.BorderActiveColor  windowDisplayOrder += 1 if thisWidget.usesScreenGUI then focusedWindow.Instance.DisplayOrder = windowDisplayOrder + Iris._config.DisplayOrderOffset end if thisWidget.state.isUncollapsed.value == false then thisWidget.state.isUncollapsed:set(true) end local firstSelectedObject = GuiService.SelectedObject if firstSelectedObject then if focusedWindow.Instance.TitleBar.Visible then GuiService:Select(focusedWindow.Instance.TitleBar) else GuiService:Select(focusedWindow.Instance.ChildContainer) end end end end UserInputService.InputBegan:Connect(function(input, gameProcessedEvent) if not gameProcessedEvent and input.UserInputType == Enum.UserInputType.MouseButton1 then Iris.SetFocusedWindow(nil) end if input.KeyCode == Enum.KeyCode.Tab and (UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or UserInputService:IsKeyDown(Enum.KeyCode.RightControl)) then quickSwapWindows() end if input.UserInputType == Enum.UserInputType.MouseButton1 then if isInsideResize and not isInsideWindow and anyFocusedWindow then local midWindow = focusedWindow.state.position.value + (focusedWindow.state.size.value / 2) local cursorPosition = UserInputService:getMouseLocation() - Vector2.new(0, 36) - midWindow  if math.abs(cursorPosition.X) * focusedWindow.state.size.value.Y >= math.abs(cursorPosition.Y) * focusedWindow.state.size.value.X then resizeFromTopBottom = Enum.TopBottom.Center resizeFromLeftRight = if math.sign(cursorPosition.X) == -1 then Enum.LeftRight.Left else Enum.LeftRight.Right else resizeFromLeftRight = Enum.LeftRight.Center resizeFromTopBottom = if math.sign(cursorPosition.Y) == -1 then Enum.TopBottom.Top else Enum.TopBottom.Bottom end isResizing = true resizeWindow = focusedWindow end end end) UserInputService.TouchTapInWorld:Connect(function(input, gameProcessedEvent) if not gameProcessedEvent then Iris.SetFocusedWindow(nil) end end) UserInputService.InputChanged:Connect(function(input) if isDragging then local mouseLocation if input.UserInputType == Enum.UserInputType.Touch then local location = input.Position mouseLocation = Vector2.new(location.X, location.Y) else mouseLocation = UserInputService:getMouseLocation() end local dragInstance = dragWindow.Instance.WindowButton local intendedPosition = mouseLocation - moveDeltaCursorPosition local newPos = fitPositionToWindowBounds(dragWindow, intendedPosition)  dragInstance.Position = UDim2.fromOffset(newPos.X, newPos.Y) dragWindow.state.position.value = newPos end if isResizing then local resizeInstance = resizeWindow.Instance.WindowButton local windowPosition = Vector2.new(resizeInstance.Position.X.Offset, resizeInstance.Position.Y.Offset) local windowSize = Vector2.new(resizeInstance.Size.X.Offset, resizeInstance.Size.Y.Offset) local mouseDelta if input.UserInputType == Enum.UserInputType.Touch then mouseDelta = input.Delta else mouseDelta = UserInputService:GetMouseLocation() - lastCursorPosition end local intendedPosition = windowPosition + Vector2.new( if resizeFromLeftRight == Enum.LeftRight.Left then mouseDelta.X else 0, if resizeFromTopBottom == Enum.TopBottom.Top then mouseDelta.Y else 0 ) local intendedSize = windowSize + Vector2.new( if resizeFromLeftRight == Enum.LeftRight.Left then -mouseDelta.X elseif resizeFromLeftRight == Enum.LeftRight.Right then mouseDelta.X else 0, if resizeFromTopBottom == Enum.TopBottom.Top then -mouseDelta.Y elseif resizeFromTopBottom == Enum.TopBottom.Bottom then mouseDelta.Y else 0 ) local newSize = fitSizeToWindowBounds(resizeWindow, intendedSize) local newPosition = fitPositionToWindowBounds(resizeWindow, intendedPosition) resizeInstance.Size = UDim2.fromOffset(newSize.X, newSize.Y) resizeWindow.state.size.value = newSize resizeInstance.Position = UDim2.fromOffset(newPosition.X, newPosition.Y) resizeWindow.state.position.value = newPosition end lastCursorPosition = UserInputService:getMouseLocation() end) UserInputService.InputEnded:Connect(function(input, gameProcessedEvent) if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and isDragging then local dragInstance = dragWindow.Instance.WindowButton isDragging = false dragWindow.state.position:set(Vector2.new(dragInstance.Position.X.Offset, dragInstance.Position.Y.Offset)) end if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and isResizing then isResizing = false resizeWindow.state.size:set(resizeWindow.Instance.WindowButton.AbsoluteSize) end if input.KeyCode == Enum.KeyCode.ButtonX then quickSwapWindows() end end) Iris.WidgetConstructor("Window", true, true, { Args = { ["Title"] = 1, ["NoTitleBar"] = 2, ["NoBackground"] = 3, ["NoCollapse"] = 4, ["NoClose"] = 5, ["NoMove"] = 6, ["NoScrollbar"] = 7, ["NoResize"] = 8, ["NoNav"] = 9, }, Generate = function(thisWidget) thisWidget.usesScreenGUI = Iris._config.UseScreenGUIs windowWidgets[thisWidget.ID] = thisWidget local Window if thisWidget.usesScreenGUI then Window = Instance.new("ScreenGui") Window.ResetOnSpawn = false Window.DisplayOrder = Iris._config.DisplayOrderOffset else Window = Instance.new("Folder") end Window.Name = "Iris_Window" local WindowButton = Instance.new("TextButton") WindowButton.Name = "WindowButton" WindowButton.BackgroundTransparency = 1 WindowButton.BorderSizePixel = 0 WindowButton.ZIndex = thisWidget.ZIndex + 1 WindowButton.LayoutOrder = thisWidget.ZIndex + 1 WindowButton.Size = UDim2.fromOffset(0, 0) WindowButton.AutomaticSize = Enum.AutomaticSize.None WindowButton.ClipsDescendants = false WindowButton.Text = "" WindowButton.AutoButtonColor = false WindowButton.Active = false WindowButton.Selectable = false WindowButton.SelectionImageObject = Iris.SelectionImageObject WindowButton.Parent = Window WindowButton.SelectionGroup = true WindowButton.SelectionBehaviorUp = Enum.SelectionBehavior.Stop WindowButton.SelectionBehaviorDown = Enum.SelectionBehavior.Stop WindowButton.SelectionBehaviorLeft = Enum.SelectionBehavior.Stop WindowButton.SelectionBehaviorRight = Enum.SelectionBehavior.Stop  WindowButton.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Keyboard then return end if thisWidget.state.isUncollapsed.value then Iris.SetFocusedWindow(thisWidget) end if not thisWidget.arguments.NoMove and input.UserInputType == Enum.UserInputType.MouseButton1 then dragWindow = thisWidget isDragging = true moveDeltaCursorPosition = UserInputService:getMouseLocation() - thisWidget.state.position.value end end) local UIStroke = Instance.new("UIStroke") UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border UIStroke.LineJoinMode = Enum.LineJoinMode.Miter UIStroke.Color = Iris._config.BorderColor UIStroke.Thickness = Iris._config.WindowBorderSize UIStroke.Parent = WindowButton local ChildContainer = Instance.new("ScrollingFrame") ChildContainer.Name = "ChildContainer" ChildContainer.Position = UDim2.fromOffset(0, 0) ChildContainer.BorderSizePixel = 0 ChildContainer.ZIndex = thisWidget.ZIndex + 2 ChildContainer.LayoutOrder = thisWidget.ZIndex + 2 ChildContainer.AutomaticSize = Enum.AutomaticSize.None ChildContainer.Size = UDim2.fromScale(1, 1) ChildContainer.Selectable = false ChildContainer.AutomaticCanvasSize = Enum.AutomaticSize.Y ChildContainer.ScrollBarImageTransparency = Iris._config.ScrollbarGrabTransparency ChildContainer.ScrollBarImageColor3 = Iris._config.ScrollbarGrabColor ChildContainer.CanvasSize = UDim2.fromScale(0, 1)  ChildContainer.BackgroundColor3 = Iris._config.WindowBgColor ChildContainer.BackgroundTransparency = Iris._config.WindowBgTransparency ChildContainer.Parent = WindowButton UIPadding(ChildContainer, Iris._config.WindowPadding) ChildContainer:getPropertyChangedSignal("CanvasPosition"):Connect(function()  thisWidget.state.scrollDistance.value = ChildContainer.CanvasPosition.Y end) ChildContainer.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Keyboard then return end if thisWidget.state.isUncollapsed.value then Iris.SetFocusedWindow(thisWidget) end end) local TerminatingFrame = Instance.new("Frame") TerminatingFrame.Name = "TerminatingFrame" TerminatingFrame.BackgroundTransparency = 1 TerminatingFrame.LayoutOrder = 0x7FFFFFF0 TerminatingFrame.BorderSizePixel = 0 TerminatingFrame.Size = UDim2.fromOffset(0, Iris._config.WindowPadding.Y + Iris._config.FramePadding.Y) TerminatingFrame.Parent = ChildContainer local ChildContainerUIListLayout = UIListLayout(ChildContainer, Enum.FillDirection.Vertical, UDim.new(0, Iris._config.ItemSpacing.Y)) ChildContainerUIListLayout.VerticalAlignment = Enum.VerticalAlignment.Top local TitleBar = Instance.new("Frame") TitleBar.Name = "TitleBar" TitleBar.BorderSizePixel = 0 TitleBar.ZIndex = thisWidget.ZIndex + 1 TitleBar.LayoutOrder = thisWidget.ZIndex + 1 TitleBar.AutomaticSize = Enum.AutomaticSize.Y TitleBar.Size = UDim2.fromScale(1, 0) TitleBar.ClipsDescendants = true TitleBar.Parent = WindowButton TitleBar.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.Touch then if not thisWidget.arguments.NoMove then dragWindow = thisWidget isDragging = true local location = input.Position moveDeltaCursorPosition = Vector2.new(location.X, location.Y) - thisWidget.state.position.value end end end) local TitleButtonSize = Iris._config.TextSize + ((Iris._config.FramePadding.Y - 1) * 2) local CollapseArrow = Instance.new("TextButton") CollapseArrow.Name = "CollapseArrow" CollapseArrow.Size = UDim2.fromOffset(TitleButtonSize,TitleButtonSize) CollapseArrow.Position = UDim2.new(0, Iris._config.FramePadding.X + 1, 0.5, 0) CollapseArrow.AnchorPoint = Vector2.new(0, 0.5) CollapseArrow.AutoButtonColor = false CollapseArrow.BackgroundTransparency = 1 CollapseArrow.BorderSizePixel = 0 CollapseArrow.ZIndex = thisWidget.ZIndex + 4 CollapseArrow.AutomaticSize = Enum.AutomaticSize.None applyTextStyle(CollapseArrow) CollapseArrow.TextXAlignment = Enum.TextXAlignment.Center CollapseArrow.TextSize = Iris._config.TextSize CollapseArrow.Parent = TitleBar CollapseArrow.MouseButton1Click:Connect(function() thisWidget.state.isUncollapsed:set(not thisWidget.state.isUncollapsed.value) end) UICorner(CollapseArrow, 1e9) applyInteractionHighlights(CollapseArrow, CollapseArrow, { ButtonColor = Iris._config.ButtonColor, ButtonTransparency = 1, ButtonHoveredColor = Iris._config.ButtonHoveredColor, ButtonHoveredTransparency = Iris._config.ButtonHoveredTransparency, ButtonActiveColor = Iris._config.ButtonActiveColor, ButtonActiveTransparency = Iris._config.ButtonActiveTransparency, }) local CloseIcon = Instance.new("TextButton") CloseIcon.Name = "CloseIcon" CloseIcon.Size = UDim2.fromOffset(TitleButtonSize, TitleButtonSize) CloseIcon.Position = UDim2.new(1, -(Iris._config.FramePadding.X + 1), 0.5, 0) CloseIcon.AnchorPoint = Vector2.new(1, 0.5) CloseIcon.AutoButtonColor = false CloseIcon.BackgroundTransparency = 1 CloseIcon.BorderSizePixel = 0 CloseIcon.ZIndex = thisWidget.ZIndex + 4 CloseIcon.AutomaticSize = Enum.AutomaticSize.None applyTextStyle(CloseIcon) CloseIcon.TextXAlignment = Enum.TextXAlignment.Center CloseIcon.Font = Enum.Font.Code CloseIcon.TextSize = Iris._config.TextSize * 2 CloseIcon.Text = ICONS.MULTIPLICATION_SIGN CloseIcon.Parent = TitleBar UICorner(CloseIcon, 1e9) CloseIcon.MouseButton1Click:Connect(function() thisWidget.state.isOpened:set(false) end) applyInteractionHighlights(CloseIcon, CloseIcon, { ButtonColor = Iris._config.ButtonColor, ButtonTransparency = 1, ButtonHoveredColor = Iris._config.ButtonHoveredColor, ButtonHoveredTransparency = Iris._config.ButtonHoveredTransparency, ButtonActiveColor = Iris._config.ButtonActiveColor, ButtonActiveTransparency = Iris._config.ButtonActiveTransparency, })  local Title = Instance.new("TextLabel") Title.Name = "Title" Title.BorderSizePixel = 0 Title.BackgroundTransparency = 1 Title.ZIndex = thisWidget.ZIndex + 3 Title.AutomaticSize = Enum.AutomaticSize.XY applyTextStyle(Title) Title.Parent = TitleBar local TitleAlign if Iris._config.WindowTitleAlign == Enum.LeftRight.Left then TitleAlign = 0 elseif Iris._config.WindowTitleAlign == Enum.LeftRight.Center then TitleAlign = 0.5 else TitleAlign = 1 end Title.Position = UDim2.fromScale(TitleAlign, 0) Title.AnchorPoint = Vector2.new(TitleAlign, 0) UIPadding(Title, Iris._config.FramePadding) local ResizeButtonSize = Iris._config.TextSize + Iris._config.FramePadding.X local ResizeGrip = Instance.new("TextButton") ResizeGrip.Name = "ResizeGrip" ResizeGrip.AnchorPoint = Vector2.new(1, 1) ResizeGrip.Size = UDim2.fromOffset(ResizeButtonSize, ResizeButtonSize) ResizeGrip.AutoButtonColor = false ResizeGrip.BorderSizePixel = 0 ResizeGrip.BackgroundTransparency = 1 ResizeGrip.Text = ICONS.BOTTOM_RIGHT_CORNER ResizeGrip.ZIndex = thisWidget.ZIndex + 3 ResizeGrip.Position = UDim2.fromScale(1, 1) ResizeGrip.TextSize = ResizeButtonSize ResizeGrip.TextColor3 = Iris._config.ButtonColor ResizeGrip.TextTransparency = Iris._config.ButtonTransparency ResizeGrip.LineHeight = 1.10  ResizeGrip.Selectable = false  applyInteractionHighlights(ResizeGrip, ResizeGrip, { ButtonColor = Iris._config.ButtonColor, ButtonTransparency = Iris._config.ButtonTransparency, ButtonHoveredColor = Iris._config.ButtonHoveredColor, ButtonHoveredTransparency = Iris._config.ButtonHoveredTransparency, ButtonActiveColor = Iris._config.ButtonActiveColor, ButtonActiveTransparency = Iris._config.ButtonActiveTransparency, }, "Text") ResizeGrip.MouseButton1Down:Connect(function() if not anyFocusedWindow or not (focusedWindow == thisWidget) then Iris.SetFocusedWindow(thisWidget)  end isResizing = true resizeFromTopBottom = Enum.TopBottom.Bottom resizeFromLeftRight = Enum.LeftRight.Right resizeWindow = thisWidget end) local ResizeBorder = Instance.new("TextButton") ResizeBorder.Name = "ResizeBorder" ResizeBorder.BackgroundTransparency = 1 ResizeBorder.BorderSizePixel = 0 ResizeBorder.ZIndex = thisWidget.ZIndex ResizeBorder.LayoutOrder = thisWidget.ZIndex ResizeBorder.Size = UDim2.new(1, Iris._config.WindowResizePadding.X * 2, 1, Iris._config.WindowResizePadding.Y * 2) ResizeBorder.Position = UDim2.fromOffset(-Iris._config.WindowResizePadding.X, -Iris._config.WindowResizePadding.Y) WindowButton.AutomaticSize = Enum.AutomaticSize.None ResizeBorder.ClipsDescendants = false ResizeBorder.Text = "" ResizeBorder.AutoButtonColor = false ResizeBorder.Active = true ResizeBorder.Selectable = false ResizeBorder.Parent = WindowButton ResizeBorder.MouseEnter:Connect(function() if focusedWindow == thisWidget then isInsideResize = true end end) ResizeBorder.MouseLeave:Connect(function() if focusedWindow == thisWidget then isInsideResize = false end end) WindowButton.MouseEnter:Connect(function() if focusedWindow == thisWidget then isInsideWindow = true end end) WindowButton.MouseLeave:Connect(function() if focusedWindow == thisWidget then isInsideWindow = false end end) ResizeGrip.Parent = WindowButton return Window end, Update = function(thisWidget) local WindowButton = thisWidget.Instance.WindowButton local TitleBar = WindowButton.TitleBar local Title = TitleBar.Title local ChildContainer = WindowButton.ChildContainer local ResizeGrip = WindowButton.ResizeGrip local TitleBarWidth = Iris._config.TextSize + Iris._config.FramePadding.Y * 2 ResizeGrip.Visible = not thisWidget.arguments.NoResize if thisWidget.arguments.NoScrollbar then ChildContainer.ScrollBarThickness = 0 else ChildContainer.ScrollBarThickness = Iris._config.ScrollbarSize end if thisWidget.arguments.NoTitleBar then TitleBar.Visible = false ChildContainer.Size = UDim2.new(1, 0, 1, 0) ChildContainer.CanvasSize = UDim2.new(0, 0, 1, 0) ChildContainer.Position = UDim2.fromOffset(0, 0) else TitleBar.Visible = true ChildContainer.Size = UDim2.new(1, 0, 1, -TitleBarWidth) ChildContainer.CanvasSize = UDim2.new(0, 0, 1, -TitleBarWidth) ChildContainer.Position = UDim2.fromOffset(0, TitleBarWidth) end if thisWidget.arguments.NoBackground then ChildContainer.BackgroundTransparency = 1 else ChildContainer.BackgroundTransparency = Iris._config.WindowBgTransparency end local TitleButtonPaddingSize = Iris._config.FramePadding.X + Iris._config.TextSize + Iris._config.FramePadding.X * 2 if thisWidget.arguments.NoCollapse then TitleBar.CollapseArrow.Visible = false TitleBar.Title.UIPadding.PaddingLeft = UDim.new(0, Iris._config.FramePadding.X) else TitleBar.CollapseArrow.Visible = true TitleBar.Title.UIPadding.PaddingLeft = UDim.new(0, TitleButtonPaddingSize) end if thisWidget.arguments.NoClose then TitleBar.CloseIcon.Visible = false TitleBar.Title.UIPadding.PaddingRight = UDim.new(0, Iris._config.FramePadding.X) else TitleBar.CloseIcon.Visible = true TitleBar.Title.UIPadding.PaddingRight = UDim.new(0, TitleButtonPaddingSize) end Title.Text = thisWidget.arguments.Title or "" end, Discard = function(thisWidget) if focusedWindow == thisWidget then focusedWindow = nil anyFocusedWindow = false end if dragWindow == thisWidget then dragWindow = nil isDragging = false end if resizeWindow == thisWidget then resizeWindow = nil isResizing = false end windowWidgets[thisWidget.ID] = nil thisWidget.Instance:Destroy() discardState(thisWidget) end, ChildAdded = function(thisWidget) return thisWidget.Instance.WindowButton.ChildContainer end, UpdateState = function(thisWidget) local stateSize = thisWidget.state.size.value local statePosition = thisWidget.state.position.value local stateIsUncollapsed = thisWidget.state.isUncollapsed.value local stateIsOpened = thisWidget.state.isOpened.value local stateScrollDistance = thisWidget.state.scrollDistance.value local WindowButton = thisWidget.Instance.WindowButton WindowButton.Size = UDim2.fromOffset(stateSize.X, stateSize.Y) WindowButton.Position = UDim2.fromOffset(statePosition.X, statePosition.Y) local TitleBar = WindowButton.TitleBar local ChildContainer = WindowButton.ChildContainer local ResizeGrip = WindowButton.ResizeGrip if stateIsOpened then if thisWidget.usesScreenGUI then thisWidget.Instance.Enabled = true WindowButton.Visible = true else WindowButton.Visible = true end thisWidget.events.opened = true else if thisWidget.usesScreenGUI then thisWidget.Instance.Enabled = false WindowButton.Visible = false else WindowButton.Visible = false end thisWidget.events.closed = true end if stateIsUncollapsed then TitleBar.CollapseArrow.Text = ICONS.DOWN_POINTING_TRIANGLE ChildContainer.Visible = true if thisWidget.arguments.NoResize == false then ResizeGrip.Visible = true end WindowButton.AutomaticSize = Enum.AutomaticSize.None thisWidget.events.uncollapsed = true else local collapsedHeight = Iris._config.TextSize + Iris._config.FramePadding.Y * 2 TitleBar.CollapseArrow.Text = ICONS.RIGHT_POINTING_TRIANGLE ChildContainer.Visible = false ResizeGrip.Visible = false WindowButton.Size = UDim2.fromOffset(stateSize.X, collapsedHeight) thisWidget.events.collapsed = true end if stateIsOpened and stateIsUncollapsed then Iris.SetFocusedWindow(thisWidget) else TitleBar.BackgroundColor3 = Iris._config.TitleBgCollapsedColor TitleBar.BackgroundTransparency = Iris._config.TitleBgCollapsedTransparency WindowButton.UIStroke.Color = Iris._config.BorderColor Iris.SetFocusedWindow(nil) end  if stateScrollDistance and stateScrollDistance ~= 0 then local callbackIndex = #Iris._postCycleCallbacks + 1 local desiredCycleTick = Iris._cycleTick + 1 Iris._postCycleCallbacks[callbackIndex] = function() if Iris._cycleTick == desiredCycleTick then ChildContainer.CanvasPosition = Vector2.new(0, stateScrollDistance) Iris._postCycleCallbacks[callbackIndex] = nil end end end end, GenerateState = function(thisWidget) if thisWidget.state.size == nil then thisWidget.state.size = Iris._widgetState(thisWidget, "size", Vector2.new(400, 300)) end if thisWidget.state.position == nil then thisWidget.state.position = Iris._widgetState( thisWidget, "position",  if anyFocusedWindow then focusedWindow.state.position.value + Vector2.new(15, 45) else Vector2.new(150, 250) ) end thisWidget.state.position.value = fitPositionToWindowBounds(thisWidget, thisWidget.state.position.value) thisWidget.state.size.value = fitSizeToWindowBounds(thisWidget, thisWidget.state.size.value) if thisWidget.state.isUncollapsed == nil then thisWidget.state.isUncollapsed = Iris._widgetState(thisWidget, "isUncollapsed", true) end if thisWidget.state.isOpened == nil then thisWidget.state.isOpened = Iris._widgetState(thisWidget, "isOpened", true) end if thisWidget.state.scrollDistance == nil then thisWidget.state.scrollDistance = Iris._widgetState(thisWidget, "scrollDistance", 0) end end }) Iris.Window = function(args, state) return Iris._Insert("Window", args, state) end end end
end;
ModuleExports["widgets"] = f_module_widgets;
local function f_module_config()
local TemplateConfig = { colorDark = {  TextColor = Color3.fromRGB(255, 255, 255), TextTransparency = 0, TextDisabledColor = Color3.fromRGB(128, 128, 128), TextDisabledTransparency = 0, BorderColor = Color3.fromRGB(110, 110, 125),    BorderActiveColor = Color3.fromRGB(160, 160, 175),  BorderTransparency = 0,  BorderActiveTransparency = 0,   WindowBgColor = Color3.fromRGB(15, 15, 15), WindowBgTransparency = 0.072, ScrollbarGrabColor = Color3.fromRGB(128, 128, 128), ScrollbarGrabTransparency = 0, TitleBgColor = Color3.fromRGB(10, 10, 10), TitleBgTransparency = 0, TitleBgActiveColor = Color3.fromRGB(41, 74, 122), TitleBgActiveTransparency = 0, TitleBgCollapsedColor = Color3.fromRGB(0, 0, 0), TitleBgCollapsedTransparency = 0.5, FrameBgColor = Color3.fromRGB(41, 74, 122), FrameBgTransparency = 0.46, FrameBgHoveredColor = Color3.fromRGB(66, 150, 250), FrameBgHoveredTransparency = 0.46, FrameBgActiveColor = Color3.fromRGB(66, 150, 250), FrameBgActiveTransparency = 0.33, ButtonColor = Color3.fromRGB(66, 150, 250), ButtonTransparency = 0.6, ButtonHoveredColor = Color3.fromRGB(66, 150, 250), ButtonHoveredTransparency = 0, ButtonActiveColor = Color3.fromRGB(15, 135, 250), ButtonActiveTransparency = 0, HeaderColor = Color3.fromRGB(66, 150, 250), HeaderTransparency = 0.31, HeaderHoveredColor = Color3.fromRGB(66, 150, 250), HeaderHoveredTransparency = 0.2, HeaderActiveColor = Color3.fromRGB(66, 150, 250), HeaderActiveTransparency = 0, SelectionImageObjectColor = Color3.fromRGB(255, 255, 255), SelectionImageObjectTransparency = 0.8, SelectionImageObjectBorderColor = Color3.fromRGB(255, 255, 255), SelectionImageObjectBorderTransparency = 0, TableBorderStrongColor = Color3.fromRGB(79, 79, 89), TableBorderStrongTransparency = 0, TableBorderLightColor = Color3.fromRGB(59, 59, 64), TableBorderLightTransparency = 0, TableRowBgColor = Color3.fromRGB(0, 0, 0), TableRowBgTransparency = 1, TableRowBgAltColor = Color3.fromRGB(255, 255, 255), TableRowBgAltTransparency = 0.94, NavWindowingHighlightColor = Color3.fromRGB(255, 255, 255), NavWindowingHighlightTransparency = 0.3, NavWindowingDimBgColor = Color3.fromRGB(204, 204, 204), NavWindowingDimBgTransparency = 0.65, SeparatorColor = Color3.fromRGB(110, 110, 128), SeparatorTransparency = 0.5, CheckMarkColor = Color3.fromRGB(66, 150, 250), CheckMarkTransparency = 0 }, colorLight = {  TextColor = Color3.fromRGB(0, 0, 0), TextTransparency = 0, TextDisabledColor = Color3.fromRGB(153, 153, 153), TextDisabledTransparency = 0, BorderColor = Color3.fromRGB(64, 64, 64),   BorderActiveColor = Color3.fromRGB(64, 64, 64),     WindowBgColor = Color3.fromRGB(240, 240, 240), WindowBgTransparency = 0, TitleBgColor = Color3.fromRGB(245, 245, 245), TitleBgTransparency = 0, TitleBgActiveColor = Color3.fromRGB(209, 209, 209), TitleBgActiveTransparency = 0, TitleBgCollapsedColor = Color3.fromRGB(255, 255, 255), TitleBgCollapsedTransparency = 0.5, ScrollbarGrabColor = Color3.fromRGB(96, 96, 96), ScrollbarGrabTransparency = 0, FrameBgColor = Color3.fromRGB(255, 255, 255), FrameBgTransparency = 0.6, FrameBgHoveredColor = Color3.fromRGB(66, 150, 250), FrameBgHoveredTransparency = 0.6, FrameBgActiveColor = Color3.fromRGB(66, 150, 250), FrameBgActiveTransparency = 0.33, ButtonColor = Color3.fromRGB(66, 150, 250), ButtonTransparency = 0.6, ButtonHoveredColor = Color3.fromRGB(66, 150, 250), ButtonHoveredTransparency = 0, ButtonActiveColor = Color3.fromRGB(15, 135, 250), ButtonActiveTransparency = 0, HeaderColor = Color3.fromRGB(66, 150, 250), HeaderTransparency = 0.31, HeaderHoveredColor = Color3.fromRGB(66, 150, 250), HeaderHoveredTransparency = 0.2, HeaderActiveColor = Color3.fromRGB(66, 150, 250), HeaderActiveTransparency = 0, SelectionImageObjectColor = Color3.fromRGB(0, 0, 0), SelectionImageObjectTransparency = 0.8, SelectionImageObjectBorderColor = Color3.fromRGB(0, 0, 0), SelectionImageObjectBorderTransparency = 0, TableBorderStrongColor = Color3.fromRGB(145, 145, 163), TableBorderStrongTransparency = 0, TableBorderLightColor = Color3.fromRGB(173, 173, 189), TableBorderLightTransparency = 0, TableRowBgColor = Color3.fromRGB(0, 0, 0), TableRowBgTransparency = 1, TableRowBgAltColor = Color3.fromRGB(77, 77, 77), TableRowBgAltTransparency = 0.91, NavWindowingHighlightColor = Color3.fromRGB(179, 179, 179), NavWindowingHighlightTransparency = 0.3, NavWindowingDimBgColor = Color3.fromRGB(51, 51, 51), NavWindowingDimBgTransparency = 0.8, SeparatorColor = Color3.fromRGB(99, 99, 99), SeparatorTransparency = 0.38,  CheckMarkColor = Color3.fromRGB(66, 150, 250), CheckMarkTransparency = 0 }, sizeDefault = {  ItemWidth = UDim.new(1, 0), ContentWidth = UDim.new(0, 125), WindowPadding = Vector2.new(8, 8), WindowResizePadding = Vector2.new(6, 6), FramePadding = Vector2.new(4, 3), ItemSpacing = Vector2.new(8, 4), ItemInnerSpacing = Vector2.new(4, 4), CellPadding = Vector2.new(4, 2), IndentSpacing = 21, TextFont = Enum.Font.Code, TextSize = 13, FrameBorderSize = 0, FrameRounding = 0, WindowBorderSize = 1, WindowTitleAlign = Enum.LeftRight.Left, ScrollbarSize = 7, }, sizeClear = {  ItemWidth = UDim.new(1, 0), ContentWidth = UDim.new(0, 125), WindowPadding = Vector2.new(12, 8), WindowResizePadding = Vector2.new(8, 8), FramePadding = Vector2.new(6, 4), ItemSpacing = Vector2.new(8, 8), ItemInnerSpacing = Vector2.new(8, 8), CellPadding = Vector2.new(4, 4), IndentSpacing = 25, TextFont = Enum.Font.Ubuntu, TextSize = 15, FrameBorderSize = 1, FrameRounding = 4, WindowBorderSize = 1, WindowTitleAlign = Enum.LeftRight.Center, ScrollbarSize = 9, }, utilityDefault = { UseScreenGUIs = true, Parent = nil, DisplayOrderOffset = 127, ZIndexOffset = 0 }} return TemplateConfig
end;
ModuleExports["config"] = f_module_config;
local function f_module_demoWindow()
return function(Iris) local showRecursiveWindow = Iris.State(false) local showWidgetInfo = Iris.State(false) local showRuntimeInfo = Iris.State(false) local showStyleEditor = Iris.State(false) local showWindowlessDemo = Iris.State(false)  local widgetDemos = { Basic = function() Iris.Tree({"Basic"}) Iris.Button({"Button"}) Iris.SmallButton({"SmallButton"}) Iris.Text({"Text"}) Iris.TextWrapped({string.rep("Text Wrapped ", 5)}) Iris.PushConfig({TextColor = Color3.fromRGB(255, 128, 0)}) Iris.Text({"Colored Text"}) Iris.PopConfig() Iris.End() end, Tree = function() Iris.Tree({"Trees"}) Iris.Tree({"Tree using SpanAvailWidth", [Iris.Args.Tree.SpanAvailWidth] = true}) Iris.End() local tree1 = Iris.Tree({"Tree with Children"}) Iris.Text({"Im inside the first tree!"}) Iris.Button({"Im a button inside the first tree!"}) Iris.Tree({"Im a tree inside the first tree!"}) Iris.Text({"I am the innermost text!"}) Iris.End() Iris.End() Iris.Checkbox({"Toggle above tree"}, {isChecked = tree1.state.isUncollapsed})  Iris.End() end, Group = function() Iris.Tree({"Groups"}) Iris.SameLine() Iris.Group() Iris.Text({"I am in group A"}) Iris.Button({"Im also in A"}) Iris.End() Iris.Separator() Iris.Group() Iris.Text({"I am in group B"}) Iris.Button({"Im also in B"}) Iris.Button({"Also group B"}) Iris.End() Iris.End() Iris.End() end, Indent = function() Iris.Tree({"Indents"}) Iris.Text({"Not Indented"}) Iris.Indent() Iris.Text({"Indented"}) Iris.Indent({7}) Iris.Text({"Indented by 7 more pixels"}) Iris.End() Iris.Indent({-7}) Iris.Text({"Indented by 7 less pixels"}) Iris.End() Iris.End() Iris.End() end, InputNum = function() Iris.Tree({"Input Num"}) local NoField, NoButtons, Min, Max, Increment, Format =  Iris.State(false), Iris.State(false), Iris.State(0), Iris.State(100), Iris.State(1), Iris.State("%d") local InputNum = Iris.InputNum({"Input Number", [Iris.Args.InputNum.NoField] = NoField.value, [Iris.Args.InputNum.NoButtons] = NoButtons.value, [Iris.Args.InputNum.Min] = Min.value, [Iris.Args.InputNum.Max] = Max.value, [Iris.Args.InputNum.Increment] = Increment.value, [Iris.Args.InputNum.Format] = Format.value, }) Iris.Text({string.format("The Value is: %d", InputNum.number.value)}) if Iris.Button({"Randomize Number"}).clicked then InputNum.number:set(math.random(1,99)) end Iris.Separator() Iris.Checkbox({"NoField"}, {isChecked = NoField}) Iris.Checkbox({"NoButtons"}, {isChecked = NoButtons}) Iris.End() end, InputText = function() Iris.Tree({"Input Text"}) Iris.PushConfig({ContentWidth = UDim.new(0, 250)}) local InputText = Iris.InputText({"Input Text Test", [Iris.Args.InputText.TextHint] = "Input Text here"}) Iris.PopConfig() Iris.Text({string.format("The text is: %s", InputText.text.value)}) Iris.End() end } local widgetDemosOrder = {"Basic", "Tree", "Group", "Indent", "InputNum", "InputText"} local function recursiveTree() local theTree = Iris.Tree({"Recursive Tree"}) if theTree.state.isUncollapsed.value then recursiveTree() end Iris.End() end local function recursiveWindow(parentCheckboxState) Iris.Window({"Recursive Window"}, {size = Iris.State(Vector2.new(150, 100)), isOpened = parentCheckboxState}) local theCheckbox = Iris.Checkbox({"Recurse Again"}) Iris.End() if theCheckbox.isChecked.value then recursiveWindow(theCheckbox.isChecked) end end  local function widgetInfo() local function parse2DArray(array) Iris.Table({#array[1]}) for i,v in array do for i,v2 in v do Iris.NextColumn() Iris.Text({tostring(v2)}) end end Iris.End() end Iris.Window({"Widget Info"},{size = Iris.State(Vector2.new(600, 300)), isOpened = showWidgetInfo}) Iris.Text({"information of Iris Widgets."}) Iris.Table({1, [Iris.Args.Table.RowBg] = false}) Iris.NextColumn() Iris.Tree({"\nIris.Text\n", [Iris.Args.Tree.NoIndent] = true, [Iris.Args.Tree.SpanAvailWidth] = true}) parse2DArray({ {"Arguments", "Events", "States"},  {"Text: String", "", "" },  }) Iris.End() Iris.NextColumn() Iris.Tree({"\nIris.TextWrapped\n", [Iris.Args.Tree.NoIndent] = true, [Iris.Args.Tree.SpanAvailWidth] = true}) parse2DArray({ {"Arguments", "Events", "States"},  {"Text: String", "", "" },  }) Iris.End() Iris.NextColumn() Iris.Tree({"\nIris.Button\n", [Iris.Args.Tree.NoIndent] = true, [Iris.Args.Tree.SpanAvailWidth] = true}) parse2DArray({ {"Arguments", "Events", "States"},  {"Text: string", "clicked: boolean", "" } }) Iris.End() Iris.NextColumn() Iris.Tree({"\nIris.SmallButton\n", [Iris.Args.Tree.NoIndent] = true, [Iris.Args.Tree.SpanAvailWidth] = true}) parse2DArray({ {"Arguments", "Events", "States"},  {"Text: string", "clicked: boolean", "" } }) Iris.End() Iris.NextColumn() Iris.Tree({"\nIris.Separator\n", [Iris.Args.Tree.NoIndent] = true, [Iris.Args.Tree.SpanAvailWidth] = true}) parse2DArray({ {"Arguments", "Events", "States"}, }) Iris.End() Iris.NextColumn() Iris.Tree({"\nIris.Indent\n", [Iris.Args.Tree.NoIndent] = true, [Iris.Args.Tree.SpanAvailWidth] = true}) parse2DArray({ {"Arguments", "Events", "States"}, {"Width: number", "", "" } }) Iris.End() Iris.NextColumn() Iris.Tree({"\nIris.SameLine\n", [Iris.Args.Tree.NoIndent] = true, [Iris.Args.Tree.SpanAvailWidth] = true}) parse2DArray({ {"Arguments", "Events", "States"}, {"Width: number", "", "" }, {"VerticalAlignment: Enum.VerticalAlignment", "", "" } }) Iris.End() Iris.NextColumn() Iris.Tree({"\nIris.Group\n", [Iris.Args.Tree.NoIndent] = true, [Iris.Args.Tree.SpanAvailWidth] = true}) parse2DArray({ {"Arguments", "Events", "States"}, }) Iris.End() Iris.NextColumn() Iris.Tree({"\nIris.Checkbox\n", [Iris.Args.Tree.NoIndent] = true, [Iris.Args.Tree.SpanAvailWidth] = true}) parse2DArray({ {"Arguments", "Events", "States" }, {"Text: string", "checked: boolean", "isChecked: boolean"}, {"", "unchecked: boolean", "" } }) Iris.End() Iris.NextColumn() Iris.Tree({"\nIris.Tree\n", [Iris.Args.Tree.NoIndent] = true, [Iris.Args.Tree.SpanAvailWidth] = true}) parse2DArray({ {"Arguments", "Events", "States" }, {"Text: string", "collapsed: boolean", "isUncollapsed: boolean"}, {"SpanAvailWidth: boolean", "uncollapsed: boolean", "" }, {"NoIndent: boolean", "", "" } }) Iris.End() Iris.NextColumn() Iris.Tree({"\nIris.InputNum\n", [Iris.Args.Tree.NoIndent] = true, [Iris.Args.Tree.SpanAvailWidth] = true}) parse2DArray({ {"Arguments", "Events", "States" }, {"Text: string", "numberChanged: boolean", "number: number"}, {"Increment: number", "", "" }, {"Min: number", "", "" }, {"Max: number", "", "" }, {"Format: string", "", "" }, {"NoButtons: boolean", "", "" }, {"NoField: boolean", "", "" } }) Iris.End() Iris.NextColumn() Iris.Tree({"\nIris.InputText\n", [Iris.Args.Tree.NoIndent] = true, [Iris.Args.Tree.SpanAvailWidth] = true}) parse2DArray({ {"Arguments", "Events", "States" }, {"Text: string", "textChanged: boolean", "text: string"}, {"TextHint: string", "", "" } }) Iris.End() Iris.NextColumn() Iris.Tree({"\nIris.Table\n", [Iris.Args.Tree.NoIndent] = true, [Iris.Args.Tree.SpanAvailWidth] = true}) parse2DArray({ {"Arguments", "Events","States"}, {"NumColumns: number", "", "" }, {"RowBg: boolean", "", "" }, {"BordersOuter: boolean", "", "" }, {"BordersInner: boolean", "", "" } }) Iris.End() Iris.NextColumn() Iris.Tree({"\nIris.Window\n", [Iris.Args.Tree.NoIndent] = true, [Iris.Args.Tree.SpanAvailWidth] = true}) parse2DArray({ {"Arguments", "Events", "States" }, {"Title: string", "closed: boolean", "size: Vector2" }, {"NoTitleBar: boolean", "opened: boolean", "position: Vector2" }, {"NoBackground: boolean", "collapsed: boolean", "isUncollapsed: boolean"}, {"NoCollapse: boolean", "uncollapsed: boolean", "isOpened: boolean" }, {"NoClose: boolean", "", "scrollDistance: number"}, {"NoMove: boolean", "", "" }, {"NoScrollbar: boolean", "", "" }, {"NoResize: boolean", "", "" } }) Iris.End() Iris.End() Iris.End() end  local function runtimeInfo() local runtimeInfoWindow = Iris.Window({"Runtime Info"}, {isOpened = showRuntimeInfo}) local lastVDOM = Iris._lastVDOM local states = Iris._states local rollingDT = Iris.State(0) local lastT = Iris.State(os.clock()) local t = os.clock() local dt = t - lastT.value rollingDT.value += (dt - rollingDT.value) * 0.2 lastT.value = t Iris.Text({string.format("Average %.3f ms/frame (%.1f FPS)", rollingDT.value*1000, 1/rollingDT.value)}) Iris.Text({string.format( "Window Position: (%d, %d), Window Size: (%d, %d)", runtimeInfoWindow.position.value.X, runtimeInfoWindow.position.value.Y, runtimeInfoWindow.size.value.X, runtimeInfoWindow.size.value.Y )}) Iris.PushConfig({ItemWidth = UDim.new(0.5, 100)}) local enteredText = Iris.InputText({"Enter an ID to learn more about it."}, {text = Iris.State(runtimeInfoWindow.ID)}).text.value Iris.PopConfig() Iris.Indent() local enteredWidget = lastVDOM[enteredText] local enteredState = states[enteredText] if enteredWidget then Iris.Table({1, [Iris.Args.Table.RowBg] = false}) Iris.Text({string.format("The ID, \"%s\", is a widget", enteredText)}) Iris.NextRow() Iris.Text({string.format("Widget is type: %s", enteredWidget.type)}) Iris.NextRow() Iris.Tree({"Widget has Args:"}, {isUncollapsed = Iris.State(true)}) for i,v in enteredWidget.arguments do Iris.Text({i .. " - " .. tostring(v)}) end Iris.End() Iris.NextRow() if enteredWidget.state then Iris.Tree({"Widget has State:"}, {isUncollapsed = Iris.State(true)}) for i,v in enteredWidget.state do Iris.Text({i .. " - " .. tostring(v.value)}) end Iris.End() end Iris.End() elseif enteredState then Iris.Table({1, [Iris.Args.Table.RowBg] = false}) Iris.Text({string.format("The ID, \"%s\", is a state", enteredText)}) Iris.NextRow() Iris.Text({string.format("Value is type: %s, Value = %s", typeof(enteredState.value), tostring(enteredState.value))}) Iris.NextRow() Iris.Tree({"state has connected widgets:"}, {isUncollapsed = Iris.State(true)}) for i,v in enteredState.ConnectedWidgets do Iris.Text({i .. " - " .. v.type}) end Iris.End() Iris.NextRow() Iris.Text({string.format("state has: %d connected functions", #enteredState.ConnectedFunctions)}) Iris.End() else Iris.Text({string.format("The ID, \"%s\", is not a state or widget", enteredText)}) end Iris.End() if Iris.Tree({"Widgets"}).isUncollapsed.value then local widgetCount = 0 local widgetStr = "" for i,v in lastVDOM do widgetCount += 1 widgetStr ..= "\n" .. v.ID .. " - " .. v.type end Iris.Text({string.format("Number of Widgets: %d", widgetCount)}) Iris.Text({widgetStr}) end Iris.End() if Iris.Tree({"States"}).isUncollapsed.value then local stateCount = 0 local stateStr = "" for i,v in states do stateCount += 1 stateStr ..= "\n" .. i .. " - " .. tostring(v.value) end Iris.Text({string.format("Number of States: %d", stateCount)}) Iris.Text({stateStr}) end Iris.End() Iris.End() end  local styleEditor do  local styleStates = {} do  for i,v in Iris._config do if typeof(v) == "Color3" then styleStates[i .. "R"] = Iris.State(v.R * 255) styleStates[i .. "G"] = Iris.State(v.G * 255) styleStates[i .. "B"] = Iris.State(v.B * 255) elseif typeof(v) == "UDim" then styleStates[i .. "Scale"] = Iris.State(v.Scale) styleStates[i .. "Offset"] = Iris.State(v.Offset) elseif typeof(v) == "Vector2" then styleStates[i .. "X"] = Iris.State(v.X) styleStates[i .. "Y"] = Iris.State(v.Y) elseif typeof(v) == "EnumItem" then styleStates[i] = Iris.State(v.Name) else styleStates[i] = Iris.State(v) end end end local function refreshStyleStates() for i,v in Iris._config do if typeof(v) == "Color3" then styleStates[i .. "R"]:set(v.R * 255) styleStates[i .. "G"]:set(v.G * 255) styleStates[i .. "B"]:set(v.B * 255) elseif typeof(v) == "UDim" then styleStates[i .. "Scale"]:set(v.Scale) styleStates[i .. "Offset"]:set(v.Offset) elseif typeof(v) == "Vector2" then styleStates[i .. "X"]:set(v.X) styleStates[i .. "Y"]:set(v.Y) elseif typeof(v) == "EnumItem" then styleStates[i]:set(v.Name) else styleStates[i]:set(v) end end end local function InputVector2(name) Iris.PushConfig({ContentWidth = UDim.new(0, 100 - Iris._config.ItemInnerSpacing.X)}) Iris.SameLine() local X = Iris.InputNum( {"", [Iris.Args.InputNum.NoButtons] = true, [Iris.Args.InputNum.Format] = "%d"}, {number = styleStates[name .. "X"]} ) local Y = Iris.InputNum( {name, [Iris.Args.InputNum.NoButtons] = true, [Iris.Args.InputNum.Format] = "%d"}, {number = styleStates[name .. "Y"]} ) if X.numberChanged or Y.numberChanged then Iris.UpdateGlobalConfig({[name] = Vector2.new(X.number.value, Y.number.value)}) end Iris.End() Iris.PopConfig() end local function InputUDim(name) Iris.PushConfig({ContentWidth = UDim.new(0, 100 - Iris._config.ItemInnerSpacing.X)}) Iris.SameLine() local Scale = Iris.InputNum( {"", [Iris.Args.InputNum.NoButtons] = true, [Iris.Args.InputNum.Format] = "%d"}, {number = styleStates[name .. "Scale"]} ) local Offset = Iris.InputNum( {name, [Iris.Args.InputNum.NoButtons] = true, [Iris.Args.InputNum.Format] = "%d"}, {number = styleStates[name .. "Offset"]} ) if Scale.numberChanged or Offset.numberChanged then Iris.UpdateGlobalConfig({[name] = UDim.new(Scale.number.value, Offset.number.value)}) end Iris.End() Iris.PopConfig() end local function InputColor4(name, transparencyName) Iris.PushConfig({ContentWidth = UDim.new(0, 50 - Iris._config.ItemInnerSpacing.X)}) Iris.SameLine() local R = Iris.InputNum( {"", [Iris.Args.InputNum.NoButtons] = true, [Iris.Args.InputNum.Format] = "%d"}, {number = styleStates[name .. "R"]} ) local G = Iris.InputNum( {"", [Iris.Args.InputNum.NoButtons] = true, [Iris.Args.InputNum.Format] = "%d"}, {number = styleStates[name .. "G"]} ) local B = Iris.InputNum( {"", [Iris.Args.InputNum.NoButtons] = true, [Iris.Args.InputNum.Format] = "%d"}, {number = styleStates[name .. "B"]} ) local A = Iris.InputNum( {name, [Iris.Args.InputNum.NoButtons] = true, [Iris.Args.InputNum.Format] = "%.3f"}, {number = styleStates[transparencyName]} ) if R.numberChanged or G.numberChanged or B.numberChanged or A.numberChanged then Iris.UpdateGlobalConfig({[name] = Color3.fromRGB(R.number.value, G.number.value, B.number.value), [transparencyName] = A.number.value}) end Iris.End() Iris.PopConfig() end local function InputInt(name) Iris.PushConfig({ContentWidth = UDim.new(0, 200)}) local I = Iris.InputNum( {name, [Iris.Args.InputNum.NoButtons] = true, [Iris.Args.InputNum.Format] = "%d"}, {number = styleStates[name]} ) if I.numberChanged then Iris.UpdateGlobalConfig({[name] = I.number.value}) end Iris.PopConfig() end local function InputEnum(name, enumType, default) Iris.PushConfig({ContentWidth = UDim.new(0, 200)}) local V = Iris.InputText( {name}, {text = styleStates[name]} ) if V.textChanged then local isValidEnum = false for _, _enumItem in ipairs(enumType:GetEnumItems()) do if _enumItem.Name == V.text.value then isValidEnum = true break end end if isValidEnum then Iris.UpdateGlobalConfig({[name] = enumType[V.text.value]}) else Iris.UpdateGlobalConfig({[name] = default}) styleStates[name]:set(tostring(default)) end end Iris.PopConfig() end local styleList = { {[0] = "Sizes", function() Iris.Text({"Main"}) InputVector2("WindowPadding") InputVector2("WindowResizePadding") InputVector2("FramePadding") InputVector2("CellPadding") InputVector2("ItemSpacing") InputVector2("ItemInnerSpacing") InputInt("IndentSpacing") InputInt("ScrollbarSize") Iris.Text({"Borders"}) InputInt("WindowBorderSize") InputInt("FrameBorderSize") Iris.Text({"Rounding"}) InputInt("FrameRounding") Iris.Text({"Alignment"}) InputEnum("WindowTitleAlign", Enum.LeftRight, Enum.LeftRight.Left) Iris.Text({"Widths"}) InputUDim("ItemWidth") InputUDim("ContentWidth") end }, {[0] = "Colors", function() InputColor4("TextColor", "TextTransparency") InputColor4("TextDisabledColor", "TextDisabledTransparency") InputColor4("BorderColor", "BorderTransparency") InputColor4("BorderActiveColor", "BorderActiveTransparency") InputColor4("WindowBgColor", "WindowBgTransparency") InputColor4("ScrollbarGrabColor", "ScrollbarGrabTransparency") InputColor4("TitleBgColor", "TitleBgTransparnecy") InputColor4("TitleBgActiveColor", "TitleBgActiveTransparency") InputColor4("TitleBgCollapsedColor", "TitleBgCollapsedTransparency") InputColor4("FrameBgColor", "FrameBgTransparency") InputColor4("FrameBgHoveredColor", "FrameBgHoveredTransparency") InputColor4("FrameBgActiveColor", "FrameBgActiveTransparency") InputColor4("ButtonColor", "ButtonTransparency") InputColor4("ButtonHoveredColor", "ButtonHoveredTransparency") InputColor4("ButtonActiveColor", "ButtonActiveTransparency") InputColor4("HeaderColor", "HeaderTransparency") InputColor4("HeaderHoveredColor", "HeaderHoveredTransparency") InputColor4("HeaderActiveColor", "HeaderActiveTransparency") InputColor4("SelectionImageObjectColor", "SelectionImageObjectTransparency") InputColor4("SelectionImageObjectBorderColor", "SelectionImageObjectBorderTransparency") InputColor4("TableBorderStrongColor", "TableBorderStrongTransparency") InputColor4("TableBorderLightColor", "TableBorderLightTransparency") InputColor4("TableRowBgColor", "TableRowBgTransparency") InputColor4("TableRowBgAltColor", "TableRowBgAltTransparency") InputColor4("NavWindowingHighlightColor", "NavWindowingHighlightTransparency") InputColor4("NavWindowingDimBgColor", "NavWindowingDimBgTransparency") InputColor4("SeparatorColor", "SeparatorTransparency") InputColor4("CheckMarkColor", "CheckMarkTransparency") end }, {[0] = "Fonts", function() InputEnum("TextFont", Enum.Font, Enum.Font.Code) InputInt("TextSize") end } } styleEditor = function() local selectedPanel = Iris.State(1)  Iris.Window({"Style Editor"}, {isOpened = showStyleEditor}) Iris.Text({"Customize the look of Iris in realtime."}) Iris.SameLine() if Iris.SmallButton({"Light Theme"}).clicked then Iris.UpdateGlobalConfig(Iris.TemplateConfig.colorLight) refreshStyleStates() end if Iris.SmallButton({"Dark Theme"}).clicked then Iris.UpdateGlobalConfig(Iris.TemplateConfig.colorDark) refreshStyleStates() end Iris.End() Iris.SameLine() if Iris.SmallButton({"Classic Size"}).clicked then Iris.UpdateGlobalConfig(Iris.TemplateConfig.sizeDefault) refreshStyleStates() end if Iris.SmallButton({"Larger Size"}).clicked then Iris.UpdateGlobalConfig(Iris.TemplateConfig.sizeClear) refreshStyleStates() end Iris.End() if Iris.SmallButton({"Reset Everything"}).clicked then Iris.UpdateGlobalConfig(Iris.TemplateConfig.colorDark) Iris.UpdateGlobalConfig(Iris.TemplateConfig.sizeDefault) refreshStyleStates() end Iris.Separator() Iris.SameLine() for i,v in ipairs(styleList) do if Iris.SmallButton({v[0]}).clicked then selectedPanel:set(i) end end Iris.End() styleList[selectedPanel:get()][1]() Iris.End() end end  local function widgetEventInteractivity() Iris.Tree({"Widget Event Interactivity"}) local clickCount = Iris.State(0) if Iris.Button({"Click to increase Number"}).clicked then clickCount:set(clickCount:get() + 1) end Iris.Text({string.format("The Number is: %d", clickCount:get())}) local showTextTimer = Iris.State(0) Iris.SameLine() if Iris.Button({"Click to show text for 20 frames"}).clicked then showTextTimer:set(20) end if showTextTimer:get() > 0 then Iris.Text({"Here i am!"}) end Iris.End() showTextTimer:set(math.max(0, showTextTimer:get() - 1)) Iris.Text({string.format("Text Timer: %d", showTextTimer:get())}) Iris.End() end  local function widgetStateInteractivity() Iris.Tree({"Widget State Interactivity"}) local checkbox0 = Iris.Checkbox({"Widget-Generated State"}) Iris.Text({`isChecked: {checkbox0.state.isChecked.value}\n`})  local checkboxState0 = Iris.State(false) local checkbox1 = Iris.Checkbox({"User-Generated State"}, {isChecked = checkboxState0}) Iris.Text({`isChecked: {checkbox1.state.isChecked.value}\n`}) local checkbox2 = Iris.Checkbox({"Widget Coupled State"}) local checkbox3 = Iris.Checkbox({"Coupled to above Checkbox"}, {isChecked = checkbox2.state.isChecked}) Iris.Text({`isChecked: {checkbox3.state.isChecked.value}\n`}) local checkboxState1 = Iris.State(false) local checkbox4 = Iris.Checkbox({"Widget and Code Coupled State"}, {isChecked = checkboxState1}) local Button0 = Iris.Button({"Click to toggle above checkbox"}) if Button0.clicked then checkboxState1:set(not checkboxState1:get()) end Iris.Text({`isChecked: {checkboxState1.value}\n`}) local checkboxState2 = Iris.State(true) local checkboxState3 = Iris.ComputedState(checkboxState2, function(newValue) return not newValue end) local checkbox5 = Iris.Checkbox({"ComputedState (dynamic coupling)"}, {isChecked = checkboxState2}) local checkbox5 = Iris.Checkbox({"Inverted of above checkbox"}, {isChecked = checkboxState3}) Iris.Text({`isChecked: {checkboxState3.value}\n`}) Iris.End() end  local function dynamicStyle() Iris.Tree({"Dynamic Styles"}) local colorH = Iris.State(0) Iris.SameLine() if Iris.Button({"Change Color"}).clicked then colorH:set(math.random()) end Iris.Text({string.format("Hue: %d", math.floor(colorH:get()*255))}) Iris.End() Iris.PushConfig({TextColor = Color3.fromHSV(colorH:get(), 1, 1)}) Iris.Text({"Text with a unique and changable color"}) Iris.PopConfig() Iris.End() end  local function tablesDemo() local showTablesTree = Iris.State(false) Iris.Tree({"Tables & Columns", [Iris.Args.Tree.NoIndent] = true}, {isUncollapsed = showTablesTree}) if showTablesTree.value == false then    Iris.End() else Iris.Text({"Table using NextRow and NextColumn syntax:"}) Iris.Table({3}) for i = 1,4 do Iris.NextRow() for i2 = 1,3 do Iris.NextColumn() Iris.Text({`Row: {i}, Column: {i2}`}) end end Iris.End() Iris.Text({""}) Iris.Text({"Table using NextColumn only syntax:"}) Iris.Table({2}) for i = 1,4 do for i2 = 1,2 do Iris.NextColumn() Iris.Text({`Row: {i}, Column: {i2}`}) end end Iris.End() Iris.Separator() local TableRowBg = Iris.State(false) local TableBordersOuter = Iris.State(false) local TableBordersInner = Iris.State(true) local TableUseButtons = Iris.State(true) Iris.Text({"Table with Customizable Arguments"}) Iris.Table({ 4, [Iris.Args.Table.RowBg] = TableRowBg.value, [Iris.Args.Table.BordersOuter] = TableBordersOuter.value, [Iris.Args.Table.BordersInner] = TableBordersInner.value }) for i = 1,3 do for i2 = 1,4 do Iris.NextColumn(); if TableUseButtons.value then Iris.Button({`Month: {i}, Week: {i2}`}) else Iris.Text({`Month: {i}, Week: {i2}`}) end end end Iris.End() Iris.Checkbox({"RowBg"}, {isChecked = TableRowBg}) Iris.Checkbox({"BordersOuter"}, {isChecked = TableBordersOuter}) Iris.Checkbox({"BordersInner"}, {isChecked = TableBordersInner}) Iris.Checkbox({"Use Buttons"}, {isChecked = TableUseButtons}) Iris.End() end end  local function windowlessDemo() Iris.PushConfig({ItemWidth = UDim.new(0, 150)}) Iris.TextWrapped({"Widgets which are placed outside of a window will appear on the top left side of the screen."}) Iris.Button() Iris.Tree() Iris.InputText() Iris.End() Iris.PopConfig() end  return function() local NoTitleBar = Iris.State(false) local NoBackground = Iris.State(false) local NoCollapse = Iris.State(false) local NoClose = Iris.State(true) local NoMove = Iris.State(false) local NoScrollbar = Iris.State(false) local NoResize = Iris.State(false) local NoNav = Iris.State(false) Iris.Window({"Iris Demo Window", [Iris.Args.Window.NoTitleBar] = NoTitleBar.value, [Iris.Args.Window.NoBackground] = NoBackground.value, [Iris.Args.Window.NoCollapse] = NoCollapse.value, [Iris.Args.Window.NoClose] = NoClose.value, [Iris.Args.Window.NoMove] = NoMove.value, [Iris.Args.Window.NoScrollbar] = NoScrollbar.value, [Iris.Args.Window.NoResize] = NoResize.value, [Iris.Args.Window.NoNav] = NoNav.value }, {size = Iris.State(Vector2.new(600, 550)), position = Iris.State(Vector2.new(100, 25))}) Iris.Text{"Iris says hello!"} Iris.Separator() Iris.Table({3, false, false, false}) Iris.NextColumn() Iris.Checkbox({"Recursive Window"}, {isChecked = showRecursiveWindow}) Iris.NextColumn() Iris.Checkbox({"Widget Info"}, {isChecked = showWidgetInfo}) Iris.NextColumn() Iris.Checkbox({"Runtime Info"}, {isChecked = showRuntimeInfo}) Iris.NextColumn() Iris.Checkbox({"Style Editor"}, {isChecked = showStyleEditor}) Iris.NextColumn() Iris.Checkbox({"Windowless"}, {isChecked = showWindowlessDemo}) Iris.End() Iris.Separator() Iris.Tree({"Window Options"}) Iris.Table({3, false, false, false}) Iris.NextColumn() Iris.Checkbox({"NoTitleBar"}, {isChecked = NoTitleBar}) Iris.NextColumn() Iris.Checkbox({"NoBackground"}, {isChecked = NoBackground}) Iris.NextColumn() Iris.Checkbox({"NoCollapse"}, {isChecked = NoCollapse}) Iris.NextColumn() Iris.Checkbox({"NoClose"}, {isChecked = NoClose}) Iris.NextColumn() Iris.Checkbox({"NoMove"}, {isChecked = NoMove}) Iris.NextColumn() Iris.Checkbox({"NoScrollbar"}, {isChecked = NoScrollbar}) Iris.NextColumn() Iris.Checkbox({"NoResize"}, {isChecked = NoResize}) Iris.NextColumn() Iris.Checkbox({"NoNav"}, {isChecked = NoNav}) Iris.End() Iris.End() widgetEventInteractivity() widgetStateInteractivity() recursiveTree() dynamicStyle() Iris.Separator() Iris.Tree({"Widgets"}) for _, name in widgetDemosOrder do widgetDemos[name]() end Iris.End() tablesDemo() Iris.End() if showRecursiveWindow.value then recursiveWindow(showRecursiveWindow) end if showWidgetInfo.value then widgetInfo() end if showRuntimeInfo.value then runtimeInfo() end if showStyleEditor.value then styleEditor() end if showWindowlessDemo.value then windowlessDemo() end end end
end;
ModuleExports["demoWindow"] = f_module_demoWindow;

local Iris = {} Iris._started = false  Iris._globalRefreshRequested = false  Iris._localRefreshActive = false  Iris._widgets = {} Iris._rootConfig = {}  Iris._config = Iris._rootConfig Iris._rootWidget = { ID = "R", type = "Root", Instance = Iris._rootInstance, ZIndex = 0,} Iris._states = {}  Iris._IDStack = {"R"} Iris._usedIDs = {}  Iris._stackIndex = 1  Iris._cycleTick = 0  Iris._widgetCount = 0  Iris._postCycleCallbacks = {} Iris._connectedFunctions = {}  function Iris._generateSelectionImageObject() if Iris.SelectionImageObject then Iris.SelectionImageObject:Destroy() end local SelectionImageObject = Instance.new("Frame") Iris.SelectionImageObject = SelectionImageObject SelectionImageObject.BackgroundColor3 = Iris._config.SelectionImageObjectColor SelectionImageObject.BackgroundTransparency = Iris._config.SelectionImageObjectTransparency SelectionImageObject.Position = UDim2.fromOffset(-1, -1) SelectionImageObject.Size = UDim2.new(1, 2, 1, 2) SelectionImageObject.BorderSizePixel = 0 local UIStroke = Instance.new("UIStroke") UIStroke.Thickness = 1 UIStroke.Color = Iris._config.SelectionImageObjectBorderColor UIStroke.Transparency = Iris._config.SelectionImageObjectBorderColor UIStroke.LineJoinMode = Enum.LineJoinMode.Round UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border UIStroke.Parent = SelectionImageObject local Rounding = Instance.new("UICorner") Rounding.CornerRadius = UDim.new(0, 2) Rounding.Parent = SelectionImageObject end function Iris._generateRootInstance()  Iris._rootInstance = Iris._widgets["Root"].Generate(Iris._widgets["Root"]) Iris._rootInstance.Parent = Iris.parentInstance Iris._rootWidget.Instance = Iris._rootInstance end function Iris._deepCompare(t1: table, t2: table)  for i, v1 in t1 do local v2 = t2[i] if type(v1) == "table" then if v2 and type(v2) == "table" then if Iris._deepCompare(v1, v2) == false then return false end else return false end else if type(v1) ~= type(v2) or v1 ~= v2 then return false end end end return true end function Iris._getID(levelsToIgnore: number)	local i = 1 + (levelsToIgnore or 1)	local ID = ""	local levelInfo = debug.info(i, "l")	while levelInfo ~= -1 and levelInfo ~= nil do		ID ..= "+" .. levelInfo		i += 1		levelInfo = debug.info(i, "l")	end	if Iris._usedIDs[ID] then		Iris._usedIDs[ID] += 1	else		Iris._usedIDs[ID] = 1	end	return ID .. ":" .. Iris._usedIDs[ID] end function Iris._generateEmptyVDOM() return { ["R"] = Iris._rootWidget } end Iris._lastVDOM = Iris._generateEmptyVDOM() Iris._VDOM = Iris._generateEmptyVDOM() function Iris._cycle() Iris._rootWidget.lastCycleTick = Iris._cycleTick if Iris._rootInstance == nil or Iris._rootInstance.Parent == nil then Iris.ForceRefresh() end for _, v in Iris._lastVDOM do if v.lastCycleTick ~= Iris._cycleTick then  Iris._DiscardWidget(v) end end Iris._lastVDOM = Iris._VDOM Iris._VDOM = Iris._generateEmptyVDOM() for i, func in Iris._postCycleCallbacks do func() end if Iris._globalRefreshRequested then   Iris._generateSelectionImageObject() Iris._globalRefreshRequested = false for i,v in Iris._lastVDOM do Iris._DiscardWidget(v) end Iris._generateRootInstance() Iris._lastVDOM = Iris._generateEmptyVDOM()  end Iris._cycleTick += 1 Iris._widgetCount = 0 table.clear(Iris._usedIDs) if Iris.parentInstance:IsA("GuiBase2d") and math.min(Iris.parentInstance.AbsoluteSize.X, Iris.parentInstance.AbsoluteSize.Y) < 100 then error("Iris Parent Instance is too small") end local compatibleParent = ( Iris.parentInstance:IsA("GuiBase2d") or  Iris.parentInstance:IsA("CoreGui") or  Iris.parentInstance:IsA("PluginGui") or  Iris.parentInstance:IsA("PlayerGui") )  if compatibleParent == false then error("Iris Parent Instance cant contain GUI") end  for _, callback in Iris._connectedFunctions do local status, _error = pcall(callback) if not status then Iris._stackIndex = 1 error(_error, 0) end if Iris._stackIndex ~= 1 then  Iris._stackIndex = 1 error("Callback has too few calls to Iris.End()", 0) end end  end function Iris._GetParentWidget() return Iris._VDOM[Iris._IDStack[Iris._stackIndex]] end Iris.Args = {} function Iris.ForceRefresh() Iris._globalRefreshRequested = true end function Iris._NoOp()  end function Iris.WidgetConstructor(type: string, hasState: boolean, hasChildren: boolean, widgetFunctions: table) local Fields = { All = { Required = { "Generate", "Discard", "Update", "Args",  }, Optional = { } }, IfState = { Required = { "GenerateState", "UpdateState" }, Optional = { } }, IfChildren = { Required = { "ChildAdded" }, Optional = { "ChildDiscarded" } } } local thisWidget = {} for _, v in Fields.All.Required do assert(widgetFunctions[v], `{v} is required for all widgets`) thisWidget[v] = widgetFunctions[v] end for _, v in Fields.All.Optional do if widgetFunctions[v] == nil then thisWidget[v] = Iris._NoOp else thisWidget[v] = widgetFunctions[v] end end if hasState then for _, v in Fields.IfState.Required do assert(widgetFunctions[v], `{v} is required for all widgets with state`) thisWidget[v] = widgetFunctions[v] end for _, v in Fields.IfState.Optional do if widgetFunctions[v] == nil then thisWidget[v] = Iris._NoOp else thisWidget[v] = widgetFunctions[v] end end end if hasChildren then for _, v in Fields.IfChildren.Required do assert(widgetFunctions[v], `{v} is required for all widgets with children`) thisWidget[v] = widgetFunctions[v] end for _, v in Fields.IfChildren.Optional do if widgetFunctions[v] == nil then thisWidget[v] = Iris._NoOp else thisWidget[v] = widgetFunctions[v] end end end thisWidget.hasState = hasState thisWidget.hasChildren = hasChildren Iris._widgets[type] = thisWidget Iris.Args[type] = thisWidget.Args local ArgNames = {} for i, v in thisWidget.Args do ArgNames[v] = i end thisWidget.ArgNames = ArgNames end function Iris.UpdateGlobalConfig(deltaStyle: table) for i, v in deltaStyle do Iris._rootConfig[i] = v end Iris.ForceRefresh() end function Iris.PushConfig(deltaStyle: table) local ID = Iris.State(-1) if ID.value == -1 then ID:set(deltaStyle) else  if Iris._deepCompare(ID:get(), deltaStyle) == false then  Iris._localRefreshActive = true ID:set(deltaStyle) end end Iris._config = setmetatable(deltaStyle, { __index = Iris._config }) end function Iris.PopConfig() Iris._localRefreshActive = false Iris._config = getmetatable(Iris._config).__index end local StateClass = {} StateClass.__index = StateClass function StateClass:get()  return self.value end function StateClass:set(newValue) self.value = newValue for _, thisWidget in self.ConnectedWidgets do Iris._widgets[thisWidget.type].UpdateState(thisWidget) end for _, thisFunc in self.ConnectedFunctions do thisFunc(newValue) end return self.value end function StateClass:onChange(funcToConnect: () -> {}) table.insert(self.ConnectedFunctions, funcToConnect) end function Iris.State(initialValue) local ID = Iris._getID(2) if Iris._states[ID] then return Iris._states[ID] else Iris._states[ID] = { value = initialValue, ConnectedWidgets = {}, ConnectedFunctions = {} } setmetatable(Iris._states[ID], StateClass) return Iris._states[ID] end end function Iris.ComputedState(firstState, onChangeCallback) local ID = Iris._getID(2) if Iris._states[ID] then return Iris._states[ID] else Iris._states[ID] = { value = onChangeCallback(firstState), ConnectedWidgets = {}, ConnectedFunctions = {} } firstState:onChange(function(newValue) Iris._states[ID]:set(onChangeCallback(newValue)) end) setmetatable(Iris._states[ID], StateClass) return Iris._states[ID] end end function Iris._widgetState(thisWidget, stateName, initialValue) local ID = thisWidget.ID .. stateName if Iris._states[ID] then Iris._states[ID].ConnectedWidgets[thisWidget.ID] = thisWidget return Iris._states[ID] else Iris._states[ID] = { value = initialValue, ConnectedWidgets = {[thisWidget.ID] = thisWidget}, ConnectedFunctions = {} } setmetatable(Iris._states[ID], StateClass) return Iris._states[ID] end end function Iris.Init(parentInstance: Instance?, eventConnection: (RBXScriptSignal | () -> {})?) if parentInstance == nil then  parentInstance = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui") end if eventConnection == nil then  eventConnection = game:GetService("RunService").Heartbeat end Iris.parentInstance = parentInstance assert(not Iris._started, "Iris.Connect can only be called once.") Iris._started = true Iris._generateRootInstance() Iris._generateSelectionImageObject()  task.spawn(function() if typeof(eventConnection) == "function" then while true do eventConnection() Iris._cycle() end else eventConnection:Connect(function() Iris._cycle() end) end end) return Iris end function Iris:Connect(callback: () -> {})  table.insert(Iris._connectedFunctions, callback) end function Iris._DiscardWidget(widgetToDiscard) local widgetParent = widgetToDiscard.parentWidget if widgetParent then Iris._widgets[widgetParent.type].ChildDiscarded(widgetParent, widgetToDiscard) end Iris._widgets[widgetToDiscard.type].Discard(widgetToDiscard) end function Iris._GenNewWidget(widgetType, arguments, widgetState, ID) local parentId = Iris._IDStack[Iris._stackIndex] local parentWidget = Iris._VDOM[parentId] local thisWidgetClass = Iris._widgets[widgetType] local thisWidget = {} setmetatable(thisWidget, thisWidget) thisWidget.ID = ID thisWidget.type = widgetType thisWidget.parentWidget = parentWidget thisWidget.events = {} local widgetInstanceParent = if Iris._config.Parent then Iris._config.Parent else Iris._widgets[parentWidget.type].ChildAdded(parentWidget, thisWidget) thisWidget.ZIndex = parentWidget.ZIndex + (Iris._widgetCount * 0x40) + Iris._config.ZIndexOffset thisWidget.Instance = thisWidgetClass.Generate(thisWidget) thisWidget.Instance.Parent = widgetInstanceParent thisWidget.arguments = arguments thisWidgetClass.Update(thisWidget) if thisWidgetClass.hasState then if widgetState then for i,v in widgetState do if not (type(v) == "table" and getmetatable(v) == StateClass) then widgetState[i] = Iris._widgetState(thisWidget, i, v) end end thisWidget.state = widgetState for i,v in widgetState do v.ConnectedWidgets[thisWidget.ID] = thisWidget end else thisWidget.state = {} end thisWidgetClass.GenerateState(thisWidget) thisWidgetClass.UpdateState(thisWidget) thisWidget.stateMT = {}  setmetatable(thisWidget.state, thisWidget.stateMT) end return thisWidget end function Iris._Insert(widgetType: string, args, widgetState) local thisWidget local ID = Iris._getID(3)  local thisWidgetClass = Iris._widgets[widgetType] Iris._widgetCount += 1 if Iris._VDOM[ID] then error("Multiple widgets cannot occupy the same ID", 3) end local arguments = {} if args ~= nil then if type(args) ~= "table" then error("Args must be a table.", 3) end for i, v in args do arguments[thisWidgetClass.ArgNames[i]] = v end end table.freeze(arguments) if Iris._lastVDOM[ID] and widgetType == Iris._lastVDOM[ID].type then  if Iris._localRefreshActive then Iris._DiscardWidget(Iris._lastVDOM[ID]) else thisWidget = Iris._lastVDOM[ID] end end if thisWidget == nil then  thisWidget = Iris._GenNewWidget(widgetType, arguments, widgetState, ID) end if Iris._deepCompare(thisWidget.arguments, arguments) == false then  thisWidget.arguments = arguments thisWidgetClass.Update(thisWidget) end  local oldEvents = thisWidget.events thisWidget.events = {} if thisWidgetClass.hasState then thisWidget.__index = thisWidget.state thisWidget.stateMT.__index = oldEvents else thisWidget.__index = oldEvents end thisWidget.lastCycleTick = Iris._cycleTick if thisWidgetClass.hasChildren then Iris._stackIndex += 1 Iris._IDStack[Iris._stackIndex] = thisWidget.ID end Iris._VDOM[ID] = thisWidget  return thisWidget end function Iris.Append(userInstance) local parentWidget = Iris._GetParentWidget() local widgetInstanceParent if Iris._config.Parent then widgetInstanceParent = Iris._config.Parent else widgetInstanceParent = Iris._widgets[parentWidget.type].ChildAdded(parentWidget, {type = "userInstance"}) end userInstance.Parent = widgetInstanceParent end function Iris.End() if Iris._stackIndex == 1 then error("Callback has too many calls to Iris.End()", 2) end Iris._IDStack[Iris._stackIndex] = nil Iris._stackIndex -= 1 end Iris.TemplateConfig = require("config") Iris.UpdateGlobalConfig(Iris.TemplateConfig.colorDark)  Iris.UpdateGlobalConfig(Iris.TemplateConfig.sizeDefault) Iris.UpdateGlobalConfig(Iris.TemplateConfig.utilityDefault) Iris._globalRefreshRequested = false  require("widgets")(Iris) Iris.ShowDemoWindow = require("demoWindow")(Iris) return Iris